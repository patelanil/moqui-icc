<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <service verb="generate" noun="BrokeredOrderItemsFeedOld" transaction-timeout="1800" authenticate="anonymous-all">
        <description>WARNING: This is deprecated, use generate#BrokeredOrderItemsFeed service to generate Brokered Order Items Feed.</description>
        <in-parameters>
            <parameter name="orderId">
                <description>Parameter to fetch Order details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch Order details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote Id for generating the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Brokered Orders Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - DISTRIBUTION_CENTER,PHYSICAL_STORE,VIRTUAL_FACILITY and for single value use - DISTRIBUTION_CENTER.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product store ids for generating Brokered Orders Items Feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE and for single value use - SM_STORE.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Brokered Order Items Feed file of HotWax for parentFacilityTypeId ${parentFacilityTypeIds}, Order ${orderId} at time ${nowDate}"/>

            <!-- Fetch items from the Brokered OrderItemsSyncQueue for identifying the orders ready for preparing
                the Brokered Order Items Feed -->
            <entity-find entity-name="co.hotwax.warehouse.BrokeredOrderItemsSyncQueue" distinct="true" list="brokeredOrderItemsSyncQueueItr">
                <econdition field-name="orderId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                <econdition field-name="itemStatusId" value="ITEM_APPROVED"/>
                <econdition field-name="productStoreId" operator="in" from="productStoreIds" ignore-if-empty="true"/>
                <use-iterator/>
            </entity-find>

            <!-- If no orders in BrokeredOrderItemsSyncQueue, then don't generate the file -->
            <if condition="!brokeredOrderItemsSyncQueueItr.hasNext()">
                <return message="No eligible orders for Brokered Order Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
               then set the productStoreId to a default value as the feed being generated contains the Brokered order items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <!-- Prepare Brokered Order Items Feed JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                        [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss'),
                         productStoreId:productStoreId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the Brokered Order Items Feed files  -->
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File brokeredOrderItemsFeedFile = new File(jsonFilePath)
                    if (!brokeredOrderItemsFeedFile.parentFile.exists()) brokeredOrderItemsFeedFile.parentFile.mkdirs()

                    PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, brokeredOrderItemsFeedFile)

                    JsonFactory jsonFactory = new JsonFactory();
                    JsonGenerator generator = jsonFactory.createGenerator(pw)
                    generator.writeStartArray()
            </script>
            <iterate list="brokeredOrderItemsSyncQueueItr" entry="orderItem">

                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <set field="orderItemAdjustmentsList" from="orderAdjustmentList.findAll({orderItem.orderItemSeqId.equals(it.orderItemSeqId)})"/>
                <set field="orderAdjustmentsList" from="orderAdjustmentList.findAll({'_NA_'.equals(it.orderItemSeqId)})"/>

                <!-- Fetch the SKU and UPCA from GoodIdentification -->
                <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                    <econdition field-name="productId" from="orderItem.productId"/>
                </entity-find>

                <!-- Fetch all Order Identifications for the Order Id -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                </entity-find>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing details from PostalAddressView -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="billOrderContactMechList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" value="BILLING_LOCATION"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- Prepare the Ship To Address details -->
                <if condition="orderItem.postalContactMechId">
                    <!-- Get the shipTo details from PostalAddressView using the contactMechId of BrokeredOrderItemsSyncQueue -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                        <field-map field-name="contactMechId" from="orderItem.postalContactMechId"/>
                    </entity-find-one>

                    <!-- Check if address is residential or not -->
                    <service-call name="co.hotwax.ofbiz.OrderServices.check#IsResidentialAddress" in-map="[contactMechId:orderItem.postalContactMechId]" out-map="isShipToResidential"/>

                    <!-- Set the Residential Address Flag value in the shipTo map -->
                    <set field="shipToAddress" from="shipToAddressMap?.getMap()"/>
                    <set field="shipToAddress?.isResidentialAddress" from="isShipToResidential.isResidentialAddress"/>
                </if>

                <!-- Prepare the Bill To Address details -->
                <set field="billToContactMechId" from="billOrderContactMechList.first?.contactMechId"/>
                <if condition="billToContactMechId">
                    <!-- Check if address is residential or not -->
                    <service-call name="co.hotwax.ofbiz.OrderServices.check#IsResidentialAddress" in-map="[contactMechId:billToContactMechId]" out-map="isBillToResidential"/>

                <!-- If billOrderContactMechList then fetch the billTo details from PostalAddressView using the contactMechId -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                        <field-map field-name="contactMechId" from="billToContactMechId"/>
                    </entity-find-one>

                <!-- Set the Residential Address Flag value in the billTo map -->
                    <set field="billToAddress" from="billToAddressMap?.getMap()"/>
                    <set field="billToAddress?.isResidentialAddress" from="isBillToResidential.isResidentialAddress"/>
                </if>

                <!-- Get all Party Identifications for a partyId -->
                <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                    <econdition field-name="partyId" from="orderItem.customerPartyId"/>
                </entity-find>

                <!-- Get order item attributes to get information about pre-order item property -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAttribute" list="orderItemAttributes">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                    <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                </entity-find>

                <!-- Prepare the Item Detail map -->
                <set field="orderItemDetail" from="orderItem.getMap() + [billTo:billToAddress,
                    shipTo:shipToAddress, orderAdjustments:orderAdjustmentsList, orderItemAdjustments:orderItemAdjustmentsList,
                    goodIdentifications:goodIdentificationList, orderIdentifications:orderIdentificationList,
                    customerPartyIdentifications:partyIdentificationList, orderItemAttributes:orderItemAttributes]"/>

                <!-- NOTE: Handling added to create/update ExternalFulfillmentOrderItem for the scenario
                    of Reject & Re-broker Order Item.
                    1. An order item is brokered to a Fulfillment Location, sent in the feed, and the history
                    record gets created in the ExternalFulfillmentOrderItem entity.
                    2. The item gets rejected from the location.
                    3. Due to this, the same record of ExternalFulfillmentOrderItem for the item gets
                    updated in HC to change the fulfillmentStatus from 'Sent' to 'Reject'.
                    4. Next day, that item gets re-brokered to the same location.
                    5. The feed will pick the item as eligible record, and it is sent again as part of the feed
                    since the view has condition to be Fulfillment Status either empty or Reject in the
                    ExternalFulfillmentOrderItem entity.
                    6. If we have handling to everytime create the record in ExternalFulfillmentOrderItem entity,
                    the new history record gets created again for this item with the same shipGroupSeqId.
                    7. For the next run of the feed, it will pick up the same item again as 1 record with Reject
                    status is available in ExternalFulfillmentOrderItem entity.
                    8. This is not the expected behavior as the order item should not be picked up again
                    for the Feed as it is already sent as part of the feed.
                    9. So we should create/update the record to handle such scenarios.
                    10 NOTE that if item gets re-brokered to a different location after being rejected, then
                    this will not create issue as history record will get created for the new shipGroupSeqId.
                    11. Issue in gitlab - https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/27 -->
                <!-- If history is existing, we always get externalFulfillmentOrderItemId from the view,
                    so update the record for the same shipGroupSeqId for the Order Item -->
                <if condition="orderItem.externalFulfillmentOrderItemId">
                    <then>
                        <service-call name="update#co.hotwax.integration.order.ExternalFulfillmentOrderItem"
                                in-map="[externalFulfillmentOrderItemId:orderItem.externalFulfillmentOrderItemId,
                                fulfillmentStatus:'Sent']"/>
                    </then>
                    <else>
                    <!-- Note - This is done as part of initial implementation approach to create the Feed history records inside the iterate.
                        TODO Explore how we can take limit while processing records, default can be 1000, it means we are generating feed for 1000 items,
                        in that way will manage mysql transactions properly. https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/46 -->
                    <!-- Create record of ExternalFulfillmentOrderItem to keep logs for the Brokered OrderItems Feed -->
                    <!-- NOTE: For history creation, reservedItemQuantity is being used and not itemQuantity. If any issue or
                             error in OISGIR in HC, then it should be alerted by error reporting for such scenarios. -->
                    <service-call name="create#co.hotwax.integration.order.ExternalFulfillmentOrderItem"
                            in-map="[orderId:orderItem.orderId, orderItemSeqId:orderItem.orderItemSeqId,
                            shipGroupSeqId:orderItem.shipGroupSeqId, fulfillmentStatus:'Sent',
                            createdDate:nowDate, quantity:orderItem.reservedItemQuantity]"/>
                    </else>
                </if>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(generator, orderItemDetail)
                </script>
            </iterate>

            <script>
                    generator.writeEndArray()
                    generator.close()
                    pw.close()
                } catch (IOException e) {
                    logger.error("Error preparing Brokered Order Items Feed files", e)
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage"
                    in-map="[messageText:jsonFilePathRef, systemMessageTypeId:systemMessageTypeId,
                    systemMessageRemoteId:systemMessageRemoteId, productStoreId:productStoreId]" out-map="brokeredSystemMessageOut"/>

            <log message="Generating Brokered Order Items Feed file with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${brokeredSystemMessageOut.systemMessageIdList}"/>
        </actions>
    </service>

    <service verb="get" noun="BrokeredOrders" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to fetch the Brokered Orders and Items to prepare the feed, which can take in a limit
            parameter to include a fixed number of orders in the Feed File.
            Eg. If the brokeredOrdersCountPerFeed parameter is set to 1000, so it will fetch 1000 eligible
            orders from the BrokeredOrderItemsSyncQueue view, and prepare the feed file. If more
            eligible orders are still available, the service will fetch the next 1000 records and
            create a new feed file and so on till the available eligible orders for the Brokered Feed.
            This way multiple feed files will be created instead of a single bulk file if large data
            set, to avoid any issues.
        </description>
        <in-parameters>
            <parameter name="brokeredOrdersCountPerFeed" type="Integer">
                <description>The number of orders to be included in the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch Order details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch Order details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote Id for generating the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Brokered Orders Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - DISTRIBUTION_CENTER,PHYSICAL_STORE,VIRTUAL_FACILITY and for single value use - DISTRIBUTION_CENTER.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product store ids for generating Brokered Orders Items Feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE and for single value use - SM_STORE.
                </description>
            </parameter>
            <parameter name="skipOrderAdjHistoryCreation" type="Boolean" default="false">
                <description>
                    Parameter to skip the history creation for Order Adjustments.
                    Defaults to False, and so always creates the history.
                    Set it to true to skip the history creation for the order adjustments.
                </description>
            </parameter>
            <parameter name="facilityGroupIds" type="List">
                <description>
                    List of facility group ids for generating Brokered Orders Items Feed.
                    For passing the facility group ids as list, add values like - M3_FAC, BJ_FAC_GRP and for single value use - M3_FAC.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <!-- Field to check the condition for the first run to always fetch the Brokered Order Items
                 for the first Feed File (replicating do-while behavior), this will be set to false after
                 first service call, and check on brokeredOrdersCount will be applicable for the next
                 service calls to prepare the Feed Files -->
            <!-- NOTE The generate#BrokeredOrderItemsFeed will be called if the brokeredOrdersCount is
                 either equal to limit or != 0  i.e. some remaining records to be processed.
                 Scenarios:
                 1. brokeredOrdersCountPerFeed = 1000 and total eligible records > 1000 (multiple Feed Files)
                 2. brokeredOrdersCountPerFeed = 1000 and total eligible records < 1000 (single Feed File)
                 3. brokeredOrdersCountPerFeed = 1000 and total eligible records = 1000 (single Feed File)
                 4. brokeredOrdersCountPerFeed = 1000 and total eligible records = 0    (No Feed File) -->
            <set field="isFirstFeed" from="true"/>
            <while condition="isFirstFeed || (brokeredOrdersCount &amp;&amp; (brokeredOrdersCount == brokeredOrdersCountPerFeed || brokeredOrdersCount != 0))">
                <!-- Added transaction=force-new as for each call to this service should be done in a new transaction
                     so that if there are multiple files being generated and an error occurs for an order in one file then
                     the transaction should be rolled back only for that file and not all the files. -->

                <!-- NOTE: Without a new transaction, if an error occurs for an order, then the whole transaction is rolled back
                     that means, no history will be created for any orders in previous generated files but the previous generated files will be sent to SFTP.
                     This can result into duplicate orders as the previous files were sent to SFTP and since history was not created
                     so these orders will be eligible and will come again in the feed. -->

                <service-call name="co.hotwax.ofbiz.OrderServices.generate#BrokeredOrderItemsFeed"
                        in-map="context" out-map="brokeredFeedOut" transaction="force-new"/>
                <set field="brokeredOrdersCount" from="brokeredFeedOut?.brokeredFeedOrdersCount"/>

                <!-- Negated the value for while condition for next runs -->
                <set field="isFirstFeed" from="false"/>
            </while>
        </actions>
    </service>
    
    <service verb="generate" noun="BrokeredOrderItemsFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Brokered Order Items Feed, which can take in a limit parameter
            to include a specific number of records in the Feed File.
            If no limit is set, default-value of limit parameter will be considered to fetch the
            eligible orders for the feed.
        </description>
        <in-parameters>
            <parameter name="brokeredOrdersCountPerFeed" type="Integer">
                <description>The number of orders to be included in the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch Order details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch Order details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote Id for generating the Brokered Order Items Feed.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Brokered Orders Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - DISTRIBUTION_CENTER,PHYSICAL_STORE,VIRTUAL_FACILITY and for single value use - DISTRIBUTION_CENTER.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product store ids for generating Brokered Orders Items Feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE and for single value use - SM_STORE.
                </description>
            </parameter>
            <parameter name="skipOrderAdjHistoryCreation" type="Boolean" default="false">
                <description>
                    Parameter to skip the history creation for Order Adjustments. 
                    Defaults to False, and so always creates the history.
                    Set it to true to skip the history creation for the order adjustments.
                </description>
            </parameter>
            <parameter name="facilityGroupIds" type="List">
                <description>
                    List of facility group ids for generating Brokered Orders Items Feed.
                    For passing the facility group ids as list, add values like - M3_FAC, BJ_FAC_GRP and for single value use - M3_FAC.
                </description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="brokeredFeedOrdersCount" type="Integer">
                <description>The number of orders in the Brokered Order Items Feed.</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- variable to use for counting the number of orders in the feed, no available method to
                 directly get the count from iterator, if .size() is used, the iterator is consumed and
                 so no data to iterate further and create the feed -->
            <set field="brokeredFeedOrdersCount" from="0"/>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Brokered Orders and Items Feed Feed file of HotWax for parentFacilityTypeId ${parentFacilityTypeIds}, Order ${orderId} at time ${nowDate}"/>

            <!-- Fetch items from the BrokeredOrderItemsSyncQueue for identifying the orders ready for preparing Feed -->
            <!-- NOTE: Removed distinct=true from entity find on BrokeredOrderItemsSyncQueue due to changes in the service as per the new format of the feed. -->
            <!-- TODO: Revisit this if any issues faced -->

            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                brokeredOrders_find = ec.entity.find("co.hotwax.warehouse.BrokeredOrderItemsSyncQueue")
                    .condition("itemStatusId", "ITEM_APPROVED")
                if(orderId) brokeredOrders_find.condition("orderId", orderId)
                if(orderItemSeqId) brokeredOrders_find.condition("orderItemSeqId", orderItemSeqId)
                if(parentFacilityTypeIds) brokeredOrders_find.condition("parentFacilityTypeId", EntityCondition.ComparisonOperator.IN, parentFacilityTypeIds)
                if(productStoreIds) brokeredOrders_find.condition("productStoreId", EntityCondition.ComparisonOperator.IN, productStoreIds)
                <!-- Select-fields to first identify eligible orders for the feed  -->
                brokeredOrders_find.limit(brokeredOrdersCountPerFeed)
                    .selectField("orderId,orderName,orderDate,orderStatusId,entryDate,currency,grandTotal,productStoreId,customerFirstName,customerLastName,salesChannel,customerPartyId,orderExternalId")
                    .orderBy("reservedDatetime")

                // Using try-with-resources to automatically close the EntityListIterator 'brokeredOrdersItr'
                try (brokeredOrdersItr = brokeredOrders_find.iterator()) {
            </script>

            <!-- If no orders in BrokeredOrderItemsSyncQueue, then don't generate the file -->
            <if condition="!brokeredOrdersItr.hasNext()">
                <return message="No eligible orders for Brokered Order and Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
               then set the productStoreId to a default value as the feed being generated contains the Brokered order and items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <!-- Prepare Brokered Order and Items Feed JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                        [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                         productStoreId:productStoreId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the Brokered Order and Items Feed File  -->
            <script>

                try {
                    //json file
                    File brokeredOrderItemsFeedFile = new File(jsonFilePath)
                    if (!brokeredOrderItemsFeedFile.parentFile.exists()) brokeredOrderItemsFeedFile.parentFile.mkdirs()
                    JsonFactory jsonFactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, brokeredOrderItemsFeedFile);
                         JsonGenerator generator = jsonFactory.createGenerator(pw)) {
                        generator.writeStartArray()
            </script>

            <iterate list="brokeredOrdersItr" entry="brokeredOrder">
                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <!-- Default value of isShippingChargesSent variable is 'Y' -->
                <!-- TODO this field name could also be renamed to isOrderAdjustmetsSent, 
                     we will take this in future, as currently field is being used in custom
                     transformations and would require changes in Specs wherever this is used. -->
                <set field="isShippingChargesSent" value="Y"/>
                <!-- Fetch the Shipping Charges and Shipping Sales Tax from OrderAdjustmentAndHistory View -->
                <!-- 1. This View is created for the purpose to maintain the Order level Adjustments history which are sent as part of Feed to external systems.
                     2. The condition on the view is such that we it will fetch Order level adjustments which are not sent to external systems.
                     3. NOTE: For now only Shipping Charges, Shipping Sales tax and Shipping Adjustment is considered as the Order level
                        Adjustments for which we are maintaining the history.-->
                <!-- Based on the input of skipOrderAdjHistoryCreation, we can create the Order Adjustment History. -->
                <if condition="!skipOrderAdjHistoryCreation">
                    <entity-find entity-name="co.hotwax.financial.OrderAdjustmentAndHistory" list="orderAdjustmentHistoryList">
                        <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                        <econdition field-name="orderItemSeqId" value="_NA_"/>
                        <econdition field-name="orderAdjustmentTypeId" operator="in" value="SHIPPING_CHARGES,SHIPPING_SALES_TAX,EXT_SHIP_ADJUSTMENT"/>
                        <select-field field-name="orderAdjustmentId,orderAdjustmentTypeId,orderId,amount"/>
                    </entity-find>

                <!-- 1. Using the isShippingChargesSent field, Will identify the that shipping charges,shipping sales tax and shipping adjustment sent or not.
                     2. If isShippingChargesSent is 'Y', means shipping charges, shipping sales tax and shipping adjustment already send as part of feed.
                     3. if isShippingChargesSent is 'N', means shipping charges, shipping sales tax and shipping adjustment didn't send as part of feed.
                     4. In the OrderAdjustmentAndHistory entity only eligible records will be appeared for order level adjustment.
                     5. If OrderAdjustmentAndHistoryList is empty for an order that means order level adjustment, has been already sent in the last feed.
                     6. In this case, the isShippingChargesSent default value will send in the feed. -->
                <!-- Prepare the Order Adjustment level history for Shipping Charges, Shipping Sales Tax,shipping adjustment -->
                    <iterate list="orderAdjustmentHistoryList" entry="orderAdjustmentHistory">
                        <set field="isShippingChargesSent" value="N"/>
                        <service-call name="create#co.hotwax.integration.order.OrderAdjustmentHistory"
                                in-map="[orderAdjustmentId:orderAdjustmentHistory.orderAdjustmentId,
                                orderAdjustmentTypeId:orderAdjustmentHistory.orderAdjustmentTypeId,
                                orderId:orderAdjustmentHistory.orderId, createdDate:nowDate,
                                comments:'OrderAdjustment sent as part of Brokered Order Items Feed']"/>
                    </iterate>
                </if>

                <!-- Fetch all Order Identifications for the Order Id -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get order attributes details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAttribute" list="orderAttributesList">
                    <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                </entity-find>

                <!-- Get all Party Identifications for a partyId -->
                <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                    <econdition field-name="partyId" from="brokeredOrder.customerPartyId"/>
                </entity-find>

                <!-- Get all the Payment Preferences for the orderId Id -->
                <!-- 1. Condition added to exclude payment preferences for the statusId='PAYMENT_REFUNDED'
                        as it is not applicable for Brokered Order Items Feed.
                     2. For the Order Payment Preference list for the Brokered Order Items Feed, the scenarios
                        are identified when Order Payment Preference status is either Authorised or Settled.
                     3. The Settled Status is observed for the payment method types like Shop Pay Installment -->
                <!-- NOTE: The results are ordered by the createdDate to get the oldest payment preference record first in the list.
                     This is done to handle the scenario of multi-part payment, that will have multiple records of a statusId for a given
                     orderId. Further handling can be done in the custom transformations as required. -->
                <entity-find entity-name="co.hotwax.financial.OrderPaymentPreferenceAndType" list="orderPaymentPreferenceList">
                    <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                    <econdition field-name="statusId" operator="not-equals" value="PAYMENT_REFUNDED"/>
                    <order-by field-name="createdDate"/>
                </entity-find>
                <!-- Get the contactMechId from OrderContactMech to fetch the billing details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="billOrderContactMechList">
                    <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" operator="in" value="BILLING_LOCATION,PHONE_BILLING"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <set field="billToAddress" from="[:]"></set>

                <if condition="billOrderContactMechList">

                    <!-- Prepare the Bill To Address details -->
                    <set field="billToAddressContactMechId" from="billOrderContactMechList.find({ 'BILLING_LOCATION'.equals(it.contactMechPurposeTypeId) })?.contactMechId"/>
                    <if condition="billToAddressContactMechId">

                        <!-- If billOrderContactMechList then fetch the billTo details from PostalAddressView using the contactMechId -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                            <field-map field-name="contactMechId" from="billToAddressContactMechId"/>
                        </entity-find-one>

                        <set field="billToAddress" from="billToAddressMap ? billToAddressMap?.getMap() : [:]"/>

                        <!-- Check if address is residential or not -->
                        <service-call name="co.hotwax.ofbiz.OrderServices.check#IsResidentialAddress"
                                      in-map="[contactMechId:billToAddressContactMechId]" out-map="isBillToResidential"/>

                        <!-- Set the Residential Address Flag value in the billTo map -->
                        <set field="billToAddress.isResidentialAddress" from="isBillToResidential.isResidentialAddress"/>
                    </if>

                    <!-- Prepare the Bill To Phone details -->
                    <set field="billToPhoneContactMechId" from="billOrderContactMechList.find({ 'PHONE_BILLING'.equals(it.contactMechPurposeTypeId) })?.contactMechId"/>
                    <if condition="billToPhoneContactMechId">

                        <!-- If billOrderContactMechList then fetch the billTo details from TelecomNumber using the contactMechId -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="billToPhoneMap">
                            <field-map field-name="contactMechId" from="billToPhoneContactMechId"/>
                        </entity-find-one>
                    </if>
                </if>

                <set field="billToAddress.phone" from="billToPhoneMap?.getMap()"/>

                <!-- Prepare the orderAdjustmentsList List -->
                <set field="orderAdjustmentsList" from="orderAdjustmentList.findAll({'_NA_'.equals(it.orderItemSeqId)})"/>

                <!-- Fetch all Order items level details to prepare the Order Item list -->
                <!-- NOTE: Removed distinct=true from entity find on BrokeredOrderItemsSyncQueue due to changes in the service as per the new format of the feed. -->
                <!-- TODO: Revisit this if any issues faced -->
                <entity-find entity-name="co.hotwax.warehouse.BrokeredOrderItemsSyncQueue" list="brokeredOrderItems">
                    <econdition field-name="orderId" from="brokeredOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                    <econdition field-name="itemStatusId" value="ITEM_APPROVED"/>
                </entity-find>

                <!-- Set orderItemList List to add the order Item Detail map -->
                <set field="orderItemList" from="[]"/>

                <iterate list="brokeredOrderItems" entry="brokeredOrderItem">
                    <!-- If the parameter contains value for facilityGroupIds, then generate a feed specific to that facilityGroupId. -->
                    <if condition="facilityGroupIds">
                        <entity-find-count entity-name="org.apache.ofbiz.product.facility.FacilityGroupMember" count-field="facilityGroupMemberCount">
                            <date-filter/>
                            <econdition field-name="facilityId" from="brokeredOrderItem.facilityId"/>
                            <econdition field-name="facilityGroupId" operator="in" from="facilityGroupIds" ignore-if-empty="true"/>
                        </entity-find-count>
                        <if condition="facilityGroupMemberCount == 0"><continue/></if>
                    </if>

                    <entity-find entity-name="co.hotwax.facility.OrderFacilityChange" list="orderFacilityChangeList" limit="1">
                        <econdition field-name="orderId" from="brokeredOrderItem.orderId"/>
                        <econdition field-name="orderItemSeqId" from="brokeredOrderItem.orderItemSeqId"/>
                        <order-by field-name="-changeDatetime"/>
                    </entity-find>
                    <set field="orderFacilityChangeId" from="orderFacilityChangeList? orderFacilityChangeList[0].orderFacilityChangeId: null"/>

                    <!-- Prepare the Ship To Address details -->

                    <set field="shipToAddress" from="[:]"></set>

                    <if condition="brokeredOrderItem.postalContactMechId">
                        <!-- Get the shipTo details from PostalAddressView using the contactMechId of BrokeredOrderItemsSyncQueue -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                            <field-map field-name="contactMechId" from="brokeredOrderItem.postalContactMechId"/>
                        </entity-find-one>

                        <set field="shipToAddress" from="shipToAddressMap ? shipToAddressMap?.getMap() : [:]"/>

                        <!-- Check if address is residential or not -->
                        <service-call name="co.hotwax.ofbiz.OrderServices.check#IsResidentialAddress"
                                in-map="[contactMechId:brokeredOrderItem.postalContactMechId]" out-map="isShipToResidential"/>

                        <!-- Set the Residential Address Flag value in the shipTo map -->
                        <set field="shipToAddress.isResidentialAddress" from="isShipToResidential?.isResidentialAddress"/>
                    </if>

                    <!-- Prepare the Ship To Phone details -->
                    <if condition="brokeredOrderItem.telecomContactMechId">
                        <!-- Get the shipTo details from TelecomNumber using the telecomContactMechId of BrokeredOrderItemsSyncQueue -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="shipToPhoneMap">
                            <field-map field-name="contactMechId" from="brokeredOrderItem.telecomContactMechId"/>
                        </entity-find-one>
                    </if>

                    <set field="shipToAddress.phone" from="shipToPhoneMap?.getMap()"/>

                    <!-- Get all Good Identifications for Product -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                        <econdition field-name="productId" from="brokeredOrderItem.productId"/>
                        <date-filter/>
                    </entity-find>

                    <!-- Get Product Features for Product -->
                    <entity-find entity-name="co.hotwax.product.feature.ProductFeatureAndAppl" list="productFeatureAndApplList" cache="true">
                        <econdition field-name="productId" from="brokeredOrderItem.productId"/>
                        <econdition field-name="productFeatureApplTypeId" value="STANDARD_FEATURE"/>
                        <date-filter/>
                    </entity-find>

                    <!-- Prepare the orderItemAdjustmentsList List -->
                    <set field="orderItemAdjustmentsList" from="orderAdjustmentList.findAll({brokeredOrderItem.orderItemSeqId.equals(it.orderItemSeqId)})"/>

                    <!-- Get order item attributes to get information about pre-order item property -->
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAttribute" list="orderItemAttributes">
                        <econdition field-name="orderId" from="brokeredOrderItem.orderId"/>
                        <econdition field-name="orderItemSeqId" from="brokeredOrderItem.orderItemSeqId"/>
                    </entity-find>

                    <!-- There may be scenario when only a few facilities from all the facilities set-up are being used for external fulfillment.
                     For this, separate Facility Group could be created for such facilities, eg. Facility Group for NetSuite Fulfillment.
                     There could be further requirement to send orders to the external system which are brokered to the facilities belonging to a specific Facility Group eg. NetSuite Fulfillment.
                     In the HC Brokered Order Items Feed, all the facility group members of the brokered facility will be fetched.
                     In the Jolt Transform, order items can be further filtered out on the basis of Facility Group Id to send order items of a particular Facility Group. 
                     TODO: For now we are using Facility Group Id for such checks, NOTE that Facility Group Type is not being used as the Facility Group Id will always be unique here, If needed in future, we can create view using FacilityGroup and FacilityGroupMember entities to include Facility Group type info as well. -->
                    <entity-find entity-name="org.apache.ofbiz.product.facility.FacilityGroupMember" list="facilityGroupMemberList">
                        <date-filter/>
                        <econdition field-name="facilityId" from="brokeredOrderItem.facilityId"/>
                    </entity-find>

                    <!-- NOTE:
                         1. OrderItemAssocs is added when requirement to handle Kit Products was introduced, and for
                          this only Kit Product needs to be sent to external system like NetSuite and its
                          component products should not be sent.
                         2. To handle this generically, we included both fromOrderItemAssocs and toOrderItemAssocs.
                          Using toOrderItemAssocs, such requirements can be handled in Jolt Transforms by
                          using orderItemAssocTypeId as "KIT_COMPONENT" to filter out component order items in
                          transformations. -->
                    <!-- Get all fromOrderItemAssoc for the Order Item -->
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAssoc" list="fromOrderItemAssocList">
                        <econdition field-name="toOrderId" from="brokeredOrderItem.orderId"/>
                        <econdition field-name="toOrderItemSeqId" from="brokeredOrderItem.orderItemSeqId"/>
                    </entity-find>

                    <!-- Get all ToOrderItemAssoc for the Order Item -->
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAssoc" list="toOrderItemAssocList">
                        <econdition field-name="orderId" from="brokeredOrderItem.orderId"/>
                        <econdition field-name="orderItemSeqId" from="brokeredOrderItem.orderItemSeqId"/>
                    </entity-find>

                    <!-- Prepare the Order Item Detail map -->
                    <set field="orderItemDetail" from="brokeredOrderItem.getMap() + [orderFacilityChangeId:orderFacilityChangeId, shipTo:shipToAddress, goodIdentifications:goodIdentificationList,
                         orderItemAdjustments:orderItemAdjustmentsList, orderItemAttributes:orderItemAttributes,
                         facilityGroupMembers:facilityGroupMemberList, fromOrderItemAssocs:fromOrderItemAssocList,
                         toOrderItemAssocs:toOrderItemAssocList,productFeatures:productFeatureAndApplList]"/>

                    <script>
                        orderItemList.add(orderItemDetail)
                    </script>

                    <!-- NOTE: Handling added to create/update ExternalFulfillmentOrderItem for the scenario
                    of Reject & Re-broker Order Item.
                    1. An order item is brokered to a Fulfillment Location, sent in the feed, and the history
                    record gets created in the ExternalFulfillmentOrderItem entity.
                    2. The item gets rejected from the location.
                    3. Due to this, the same record of ExternalFulfillmentOrderItem for the item gets
                    updated in HC to change the fulfillmentStatus from 'Sent' to 'Reject'.
                    4. Next day, that item gets re-brokered to the same location.
                    5. The feed will pick the item as eligible record, and it is sent again as part of the feed
                    since the view has condition to be Fulfillment Status either empty or Reject in the
                    ExternalFulfillmentOrderItem entity.
                    6. If we have handling to everytime create the record in ExternalFulfillmentOrderItem entity,
                    the new history record gets created again for this item with the same shipGroupSeqId.
                    7. For the next run of the feed, it will pick up the same item again as 1 record with Reject
                    status is available in ExternalFulfillmentOrderItem entity.
                    8. This is not the expected behavior as the order item should not be picked up again
                    for the Feed as it is already sent as part of the feed.
                    9. So we should create/update the record to handle such scenarios.
                    10 NOTE that if item gets re-brokered to a different location after being rejected, then
                    this will not create issue as history record will get created for the new shipGroupSeqId.
                    11. Issue in gitlab - https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/27 -->
                    <!-- If history is existing, we always get externalFulfillmentOrderItemId from the view,
                        so update the record for the same shipGroupSeqId for the Order Item -->
                    <if condition="brokeredOrderItem.externalFulfillmentOrderItemId"><then>
                        <!-- Update the ExternalFulfillmentOrderItem records for the same shipGroupSeqId for an Order Item -->
                        <service-call name="update#co.hotwax.integration.order.ExternalFulfillmentOrderItem"
                                in-map="[externalFulfillmentOrderItemId:brokeredOrderItem.externalFulfillmentOrderItemId,
                                fulfillmentStatus:'Sent']"/>
                    </then><else>
                        <!-- Create record of ExternalFulfillmentOrderItem to keep logs for the Brokered Order and Items Feed -->
                        <!-- NOTE: For history creation, reservedItemQuantity is being used and not itemQuantity. If any issue or
                             error in OISGIR in HC, then it should be alerted by error reporting for such scenarios. -->
                        <service-call name="create#co.hotwax.integration.order.ExternalFulfillmentOrderItem" in-map="[orderId:brokeredOrderItem.orderId,
                                orderItemSeqId:brokeredOrderItem.orderItemSeqId, shipGroupSeqId:brokeredOrderItem.shipGroupSeqId,
                                fulfillmentStatus:'Sent', createdDate:nowDate, quantity:brokeredOrderItem.reservedItemQuantity]"/>
                    </else></if>
                </iterate>
                <!-- Check if the orderItem is not empty to prepare order details.-->
                <if condition="!orderItemList.isEmpty()">
                <!-- Prepare the Order Detail map -->
                    <set field="orderDetail" from="brokeredOrder.getMap() + [isShippingChargesSent:isShippingChargesSent, billTo:billToAddress,
                         orderIdentifications:orderIdentificationList, customerPartyIdentifications:partyIdentificationList,
                         payments:orderPaymentPreferenceList, orderAdjustments:orderAdjustmentsList, orderAttributes:orderAttributesList, orderItems:orderItemList]"/>

                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(generator, orderDetail)

                    //incrementing the brokeredFeedOrdersCount for total orders included in the feed
                    //this field is used in get#BrokeredOrderItems service to prepare multiple feed files if applicable
                    brokeredFeedOrdersCount++
                </script>
                </if>
            </iterate>
            <script>
                        generator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.error("Error preparing Brokered Order Feed files", e)
                }
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[messageText:jsonFilePathRef, systemMessageTypeId:systemMessageTypeId,
                    systemMessageRemoteId:systemMessageRemoteId, productStoreId:productStoreId]" out-map="brokeredSystemMessageOut"/>

            <return message="Created the Brokered Order Items Feed file with orders count
                ${brokeredFeedOrdersCount} at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId}
                and remote ${systemMessageRemoteId} saved response in messages
                ${brokeredSystemMessageOut.systemMessageId}"/>
        </actions>
    </service>

    <service verb="generate" noun="FulfilledOrderItemsFeedOld" authenticate="anonymous-all" transaction-timeout="1800">
        <description>
            WARNING: This is deprecated, use generate#FulfilledOrderItemsFeed service.
            This service generates Fulfilled Order Items feed item wise.
        </description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote id for generating the Reports.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch fulfilled Order items details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch Order details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="sinceDate">
                <description>Parameter to fetch Fulfilled Order Items after the specified date.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Reports.</description>
            </parameter>
            <parameter name="parentFacilityTypeId" required="true">
                <description>Parameter to get Fulfilled Order items details for specific parentFacilityTypeId.</description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product Store Ids for generating Fullfilled orders item feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE and for single value use - SM_STORE.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Fulfilled Order Items Feed file of HotWax for parentFacilityTypeId ${parentFacilityTypeId}, Order ${orderId}, at time ${nowDate}"/>

            <!-- Fetch items from the BrokeredOrderItemsSyncQueue for identifying the orders ready for preparing
            the fulfilled order items Feed -->
            <entity-find entity-name="co.hotwax.warehouse.BrokeredOrderItemsSyncQueue" list="fulfilledOrderItemsItr">
                <econdition field-name="orderId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                <econdition field-name="parentFacilityTypeId"/>
                <econdition field-name="productStoreId" operator="in" from="productStoreIds" ignore-if-empty="true"/>
                <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                this can be needed where we want to ignore some historical data which is not required to sync. -->
                <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                <use-iterator/>
            </entity-find>

            <!-- If no orders in BrokeredOrderItemsSyncQueue, then don't generate the file -->
            <if condition="!fulfilledOrderItemsItr.hasNext()">
                <return message="No eligible orders for Fulfilled Order Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
              then set the productStoreId to a default value as the feed being generated contains the Fulfilled order items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Prepare fulfilled order items JSON File Path -->
            <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager'"/>
            <set field="jsonFilePathRef" value="${contentRoot}/FulfilledOrderItemsFeed/${parentFacilityTypeId}/${productStoreId}-HotWaxFulfilledOrderItemsFeed-${ec.l10n.format(ec.user.nowTimestamp, 'yyyy-MM-dd-HH-mm-ss', null, TimeZone.getDefault())}.json"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the fulfilled order items Feed files  -->
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File fulfilledOrderItemsFeedFile = new File(jsonFilePath)
                    if (!fulfilledOrderItemsFeedFile.parentFile.exists()) fulfilledOrderItemsFeedFile.parentFile.mkdirs()

                    PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, fulfilledOrderItemsFeedFile)

                    JsonFactory jfactory = new JsonFactory();
                    JsonGenerator jGenerator = jfactory.createGenerator(pw)
                    jGenerator.writeStartArray()
            </script>
            <iterate list="fulfilledOrderItemsItr" entry="orderItem">

                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <set field="orderItemAdjustmentsList" from="orderAdjustmentList.findAll({orderItem.orderItemSeqId.equals(it.orderItemSeqId)})"/>
                <set field="orderAdjustmentsList" from="orderAdjustmentList.findAll({'_NA_'.equals(it.orderItemSeqId)})"/>

                <!-- Get all Good Identifications for Product -->
                <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                    <econdition field-name="productId" from="orderItem.productId"/>
                </entity-find>

                <!-- Get the shipTo details from PostalAddressView using the contactMechId of BrokeredOrderItemsSyncQueue -->
                <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddress">
                    <field-map field-name="contactMechId" from="orderItem?.postalContactMechId"/>
                </entity-find-one>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing details from PostalAddressView -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="billOrderContactMechList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" value="BILLING_LOCATION"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- If billOrderContactMechList then fetch the billTo details from PostalAddressView using the contactMechId -->
                <if condition="billOrderContactMechList">
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddress">
                        <field-map field-name="contactMechId" from="billOrderContactMechList?.first?.contactMechId"/>
                    </entity-find-one>
                </if>

                <!-- Fetch all Order Identifications for the Order Id -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="orderItem.orderId"/>
                </entity-find>

                <!-- Get all Party Identifications for a partyId -->
                <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                    <econdition field-name="partyId" from="orderItem.customerPartyId"/>
                </entity-find>

                <set field="orderItemDetail" from="orderItem.getMap() + [billTo:billToAddress,
                    shipTo:shipToAddress, orderAdjustments:orderAdjustmentsList, orderItemAdjustments:orderItemAdjustmentsList, goodIdentifications:goodIdentificationList,
                    orderIdentifications:orderIdentificationList, customerPartyIdentifications:partyIdentificationList]"/>

                <!-- Note - This is done as part of initial implementation approach to create the Feed history records inside the iterate.
                     TODO Explore how we can take limit while processing records, default can be 1000, it means we are generating feed for 1000 items,
                     in that way will manage mysql transactions properly. https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/46 -->
                <!-- Create record of ExternalFulfillmentOrderItem to keep logs for the Fulfilled Order Items Feed -->
                <service-call name="create#co.hotwax.integration.order.ExternalFulfillmentOrderItem" in-map="[orderId:orderItem.orderId,
                        orderItemSeqId:orderItem.orderItemSeqId, shipGroupSeqId:orderItem.shipGroupSeqId,
                        fulfillmentStatus:'Sent', createdDate:nowDate, quantity:orderItem.quantity]"/>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderItemDetail)
                </script>
            </iterate>
            <script>
                    jGenerator.writeEndArray()
                    jGenerator.close()
                    pw.close()
                } catch (IOException e) {
                    logger.info("Error preparing fulfilled order items Financial Feed file", e)
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.receive#IncomingSystemMessage"
                    in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                    messageText:jsonFilePathRef, productStoreId:productStoreId]" out-map="fulfillmentFeedSysMsgOut"/>

            <log message="Generating Fulfilled Order Items Feed file with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${fulfillmentFeedSysMsgOut.systemMessageIdList}"/>
        </actions>
    </service>
    
    <!-- The service will generate Fulfilled Order Items Feed Json as per the behaviour mentioned below.
            1. If the value of orderStatusId is passed in the service, then the service will fetch the
               eligible orders based on that orderStatusId.
               1.1 For example if the value of orderStatusId is passed as 'ORDER_COMPLETED', then the
                   service will fetch those orders where the itemStatusId is 'ITEM_COMPLETED' and
                   orderStatusId is 'ORDER_COMPLETED'.
               1.2 That means the Fulfillment feed will contain those orders that are marked as completed.
            2. If no value is passed in orderStatusId, then the feed will fetch the eligible orders
               where the itemStatusId is 'ITEM_COMPLETED'.
               2.1 NOTE: In this condition the feed will also contain the orders that are partially completed.
            3. The format for the feed is order-level wise which contains shipments information and each
               shipment contains information for the completed items.
            4. For digital type goods, there is no Shipments involved, so for the order with digital and
               physical type items, separate shipment groups will be identified based on the field
               selection of trackingIdNumber, carrierPartyId, shipmentMethodTypeId and shipToContactMechId
               and each shipment will contain its completed items.
            5. A parameter, orderTypeId, is added to the Fulfilled Order Items Feed to accommodate various
               order types. If provided, the system generates a feed specific to the given order type;
               otherwise, it defaults to generating a feed for sale orders. -->

    <service verb="generate" noun="FulfilledOrderItemsFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Fulfilled Order Items Feed JSON order wise, each order containing shipments
            list which is generated by grouping order by trackingIdNumber, carrierPartyId,
            shipmentMethodTypeId and shipToContactMechId, each shipment containing its completed items.
        </description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID for generating the Fulfilled Order Items Feed.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Fulfilled Order Items Feed.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch fulfilled order item details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch fulfilled order item details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="orderStatusId">
                <description>
                    Parameter to fetch fulfilled order item details for a specific Order Status ID like ORDER_APPROVED, ORDER_COMPLETED etc.
                </description>
            </parameter>
            <parameter name="orderTypeId" default-value="SALES_ORDER">
                <description>
                    The parameter fetches fulfilled order item details for a specific Order Type ID (e.g., SALES_ORDER, TRANSFER_ORDER).
                    If no value is passed, the default feed for SALES_ORDER will be generated.
                </description>
            </parameter>
            <parameter name="sinceDate">
                <description>Parameter to fetch fulfilled order items after a specified date.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Fulfilled Order Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - PHYSICAL_STORE,DISTRIBUTION_CENTER,VIRTUAL_FACILITY and for single value use - PHYSICAL_STORE.
                </description>
            </parameter>
            <parameter name="productTypeIds" type="List">
                <description>
                    List of product Type Ids for generating Fulfilled Order Items Feed.
                    For passing the Product Type Ids as list, add values like -
                    FINISHED_GOOD,DIGITAL_GOOD,DONATION and for single value use - FINISHED_GOOD.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product Store Ids for generating Fulfilled orders item feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE
                    and for single value use - SM_STORE.
                </description>
            </parameter>
            <parameter name="isPhysical">
                <description>
                    For passing the IsPhysical values like
                    1. isPhysical = 'Y' - Include Physical good type items.
                    2. isPhysical = 'N' - Include all the type of goods excluding the Physical good type items.
                    3. If we are not passing anything in the isPhysical then all the type of goods will be
                    considered for the feed.
                </description>
            </parameter>
            <parameter name="includeSalesChannel" type="List">
                <description>
                    Parameter to fetch fulfilled order items for orders received from specific sales channels.
                    For passing the Sales Channel values as list, add values like - CSR_CHANNEL,WEB_CHANNEL
                    and for single value use - WEB_CHANNEL
                </description>
            </parameter>
            <parameter name="excludeSalesChannel" type="List">
                <description>
                    Parameter to fetch fulfilled order items excluding orders received from specific sales channels.
                    For passing the Sales Channel values as list, add values like - POS_CHANNEL,B2B_CHANNEL
                    and for single value use - POS_CHANNEL
                </description>
            </parameter>
            <parameter name="customParametersMap" type="Map">
                <description>
                    This map defines custom conditions to fetch Fulfilled Order Items, allowing flexibility to add new conditions dynamically. This parameter expects map in a specific format including suffixes like *_op for operators and *_ic for case-insensitivity. Eg. If we want to fetch orders bases on Shopify Shop set up i.e. orders for a particular shopId, we can add the map like {"shopId": "SMUS_SHOP"}.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Fulfilled Order Items Feed file of HotWax for parentFacilityTypeId ${parentFacilityTypeIds}, Order ${orderId}, at time ${nowDate}"/>

            <!-- Fetch all Orders from FulfilledOrderItemsSyncQueue view to be included in
            the Fulfilled Order Items Feed, select-field values for only order level details -->
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                fulfilledOrders_find = ec.entity.find("co.hotwax.warehouse.FulfilledOrderItemsSyncQueue")
                    .searchFormMap(customParametersMap, null, "", "", false)
                    .condition("itemStatusId", "ITEM_COMPLETED")
                    .condition("orderTypeId", orderTypeId)
                if(orderId) fulfilledOrders_find.condition("orderId", orderId)
                if(orderItemSeqId) fulfilledOrders_find.condition("orderItemSeqId", orderItemSeqId)
                if(orderStatusId) fulfilledOrders_find.condition("orderStatusId", orderStatusId)
                if(isPhysical) fulfilledOrders_find.condition("isPhysical", isPhysical)
                if(parentFacilityTypeIds) fulfilledOrders_find.condition("parentFacilityTypeId", EntityCondition.ComparisonOperator.IN, parentFacilityTypeIds)
                if(productStoreIds) fulfilledOrders_find.condition("productStoreId", EntityCondition.ComparisonOperator.IN, productStoreIds)
                if(productTypeIds) fulfilledOrders_find.condition("productTypeId", EntityCondition.ComparisonOperator.IN, productTypeIds)
                if(includeSalesChannel) fulfilledOrders_find.condition("salesChannel", EntityCondition.ComparisonOperator.IN, includeSalesChannel)
                if(excludeSalesChannel) fulfilledOrders_find.condition("salesChannel", EntityCondition.ComparisonOperator.NOT_IN, excludeSalesChannel)
                <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                this can be needed where we want to ignore some historical data which is not required to sync. -->
                if(sinceDate) fulfilledOrders_find.havingCondition(ec.entity.conditionFactory.makeCondition("statusDatetime", EntityCondition.ComparisonOperator.GREATER_THAN, sinceDate))
                <!-- Select-fields to first identify eligible orders for the feed  -->
                fulfilledOrders_find.selectField("orderId,productStoreId,shopId")
                    .orderBy("statusDatetime")

                // Using try-with-resources to automatically close the EntityListIterator 'fulfilledOrdersItr'
                try (fulfilledOrdersItr = fulfilledOrders_find.iterator()) {
            </script>

            <!-- If no orders in FulfilledOrderItemsSyncQueue, then don't generate the file -->
            <if condition="!fulfilledOrdersItr.hasNext()">
                <return message="No eligible orders for Fulfilled Order Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
              then set the productStoreId to a default value as the feed being generated contains the Fulfilled order items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <!-- Prepare fulfilled order items JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                        [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                         productStoreId:productStoreId,shopId:customParametersMap?.shopId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the Fulfilled Order Items Feed file  -->
            <script>
                try {
                    //json file
                    File fulfilledOrderItemsFeedFile = new File(jsonFilePath)
                    if (!fulfilledOrderItemsFeedFile.parentFile.exists()) fulfilledOrderItemsFeedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, fulfilledOrderItemsFeedFile);
                         JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="fulfilledOrdersItr" entry="fulfilledOrder">
                <log message="Generating feed for the order ${fulfilledOrder.orderId}"/>

                <!-- Set shipments List to add the shipment details map -->
                <set field="shipments" from="[]"/>

                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <!-- Fetch the Shipping Charges and Shipping Sales Tax from FulfilledOrderAdjustmentAndHistory View -->
                <!-- 1. This View is created for the purpose to maintain the Order level Adjustments history which are sent as part of Feed to external systems.
                     2. The condition on the view is such that we it will fetch Order level adjustments which are not sent to external systems.
                     3. NOTE: For now only Shipping Charges, Shipping Sales tax and Shipping Adjustment is considered as the Order level
                        Adjustments for which we are maintaining the history.-->
                <entity-find entity-name="co.hotwax.financial.FulfilledOrderAdjustmentAndHistory" list="fulfilledOrderAdjustmentHistoryList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" value="_NA_"/>
                    <econdition field-name="orderAdjustmentTypeId" operator="in" value="SHIPPING_CHARGES,SHIPPING_SALES_TAX,EXT_SHIP_ADJUSTMENT"/>
                    <select-field field-name="orderAdjustmentId,orderAdjustmentTypeId,orderId,amount"/>
                </entity-find>

                <!-- Default value of isShippingChargesSent variable is 'Y' -->
                <set field="isShippingChargesSent" value="Y"/>
                <!-- 1. Using the isShippingChargesSent field, Will identify the that shipping charges,shipping sales tax and shipping adjustment sent or not.
                     2. If isShippingChargesSent is 'Y', means shipping charges, shipping sales tax and shipping adjustment already send as part of feed.
                     3. if isShippingChargesSent is 'N', means shipping charges, shipping sales tax and shipping adjustment didn't send as part of feed.
                     4. In the FulfilledOrderAdjustmentAndHistory entity only eligible records will be appeared for order level adjustment.
                     5. If fulfilledOrderAdjustmentHistoryList is empty for an order that means order level adjustment, has been already sent in the last feed.
                     6. In this case, the isShippingChargesSent default value will send in the feed. -->
                <!-- Prepare the Order Adjustment level history for Shipping Charges, Shipping Sales Tax,shipping adjustment -->
                <iterate list="fulfilledOrderAdjustmentHistoryList" entry="fulfilledOrderAdjustmentHistory">
                    <set field="isShippingChargesSent" value="N"/>
                    <service-call name="create#co.hotwax.integration.order.FulfilledOrderAdjustmentHistory"
                            in-map="[orderAdjustmentId:fulfilledOrderAdjustmentHistory.orderAdjustmentId,
                            orderAdjustmentTypeId:fulfilledOrderAdjustmentHistory.orderAdjustmentTypeId,
                            orderId:fulfilledOrderAdjustmentHistory.orderId, createdDate:nowDate,
                            comments:'Order Adjustment sent as part of Fulfilled Order Items Feed']"/>
                </iterate>

                <!-- Prepare the Order level adjustments list -->
                <set field="orderAdjustmentsList" from="orderAdjustmentList.findAll({'_NA_'.equals(it.orderItemSeqId)})"/>

                <!-- Get all the Payment Preferences for the orderId Id -->
                <!-- 1. Condition added to exclude payment preferences for the statusId='PAYMENT_REFUNDED'
                        as it is not applicable for Fulfilled Order Items Feed.
                     2. For the Order Payment Preference list for the Fulfilled Order Items Feed, the scenarios
                        are identified when Order Payment Preference status is either Authorised or Settled.
                     3. The Settled Status is observed for the payment method types like Shop Pay Installment -->
                <!-- NOTE: The results are ordered by the createdDate to get the oldest payment preference record first in the list.
                     This is done to handle the scenario of multi-part payment, that will have multiple records of a statusId for a given
                     orderId. Further handling can be done in the custom transformations as required. -->
                <entity-find entity-name="co.hotwax.financial.OrderPaymentPreferenceAndType" list="orderPaymentPreferenceList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                    <econdition field-name="statusId" operator="not-equals" value="PAYMENT_REFUNDED"/>
                    <order-by field-name="createdDate"/>
                </entity-find>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="orderContactMechList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" operator="in" value="BILLING_LOCATION,BILLING_EMAIL,PHONE_BILLING,SHIPPING_EMAIL"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- If orderContactMechList then fetch the billTo details using the contactMechIds -->
                <if condition="orderContactMechList">
                    <set field="billToAddressContactMechId" from="orderContactMechList.find{ 'BILLING_LOCATION'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="billToEmailOrderContactMech" from="orderContactMechList.find{ 'BILLING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>
                    <set field="billToPhoneContactMechId" from="orderContactMechList.find{ 'PHONE_BILLING'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="shipToEmailOrderContactMech" from="orderContactMechList?.find{ 'SHIPPING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>

                    <if condition="billToAddressContactMechId">
                        <!-- Get the BillTo Postal Address Details -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                            <field-map field-name="contactMechId" from="billToAddressContactMechId"/>
                        </entity-find-one>
                    </if>

                    <if condition="billToEmailOrderContactMech">
                        <!-- Get the BillTo Email Address Details -->
                        <entity-find-related-one value-field="billToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="billToEmailContactMech"/>
                    </if>

                    <if condition="billToPhoneContactMechId">
                        <!-- Get the BillTo Phone Number Details -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="billToPhoneDetails">
                            <field-map field-name="contactMechId" from="billToPhoneContactMechId"/>
                        </entity-find-one>
                    </if>
                </if>

                <!-- Adding the Email and Phone number details to billTo Map -->
                <!-- ToDo: Improve the schema of the billTo details map to have address map for postal details. Linked the related
                            issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                <set field="billToAddress" from="billToAddressMap ? billToAddressMap.getMap() : [:] "/>
                <set field="billToAddress.email" from="billToEmailContactMech?.infoString"/>
                <set field="billToAddress.phone" from="billToPhoneDetails"/>

                <!-- Fetch all Order Identifications for the Order Id -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get order attributes details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAttribute" list="orderAttributesList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                </entity-find>

                <!-- Fetch all Shipment details to prepare the Shipment level and Shipment Item level list -->
                <!-- The Shipment level list will include Shipment details like trackingIdNumber,
                    carrierPartyId, shipmentMethodTypeId, shipToContactMechId and shipment items.
                    The orders are grouped by the four fields and then the Shipment Item level list is
                    prepared and will include item level details.
                    Here select-field includes shipment level details -->
                <entity-find entity-name="co.hotwax.warehouse.OrderItemAndShipment" list="orderShipmentList">
                    <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                    <!-- Completed order items with 'DIGITAL_GOOD' product types,such product types are completed but no shipments are created.
                    because digital type order items are not fulfilled. So if we use econdition with shipmentStatusId ='SHIPMENT_SHIPPED',
                    then we will missed digital types order items.So for also including the digital type goods we use the or-null="true" attribute.
                    If shipmentStatusId is null then compare with the null value and fetch the record accordingly. -->
                    <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED" or-null="true"/>
                    <econdition field-name="isPhysical" ignore-if-empty="true"/>
                    <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                    <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                    <!-- The conditions above needs to be added for fetching the order shipments for the order -->
                    <having-econditions>
                        <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                        this can be needed where we want to ignore some historical data which is not required to sync. -->
                        <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                    </having-econditions>
                    <!-- Select-fields to now identify eligible order shipments for the order  -->
                    <select-field field-name="trackingNumber,carrierPartyId,actualCarrierCode,shipmentMethodTypeId,shipToContactMechId,shipToTelecomContactMechId"/>
                    <order-by field-name="statusDatetime"/>
                </entity-find>

                <iterate list="orderShipmentList" entry="orderShipment">

                    <!-- Set shipmentItems List to add the shipment Items map -->
                    <set field="shipmentItems" from="[]"/>

                    <!-- Prepare Ship To Address details using PostalAddressView -->
                    <!-- NOTE:
                        1. Preparing the Ship To Address from the contactMechId in Shipment only.
                        2. Shipments are created for physical type goods so for them contactMechId will be taken from Shipment.
                        3. For digital type goods there are no shipments. So, Ship To Address will not be prepared. -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                        <field-map field-name="contactMechId" from="orderShipment.shipToContactMechId"/>
                    </entity-find-one>

                    <!-- Get the Email Address Details -->
                    <if condition="shipToEmailOrderContactMech">
                        <entity-find-related-one value-field="shipToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="shipToEmailContactMech"/>
                    </if>

                    <!-- Get the Phone Number Details -->
                    <!-- TODO: TelecomContactMechId is from shipment entity, this should be handled. If the TelecomContactMechId is not found in shipment entity
                                then it should be fetched from OrderItemShipGroup entity. The way it is done for postalContactMechId.
                                 Related issue link: https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/445 -->
                    <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="shipToPhoneDetails">
                        <field-map field-name="contactMechId" from="orderShipment.shipToTelecomContactMechId"/>
                    </entity-find-one>

                    <!-- Adding the Email and Phone number details to shipTo Map -->
                    <!-- ToDo: Improve the schema of the shipTo details map to have address map for postal details. Linked the related
                                issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                    <set field="shipToAddress" from="shipToAddressMap ? shipToAddressMap?.getMap() : [:] "/>
                    <set field="shipToAddress.email" from="shipToEmailContactMech?.infoString"/>
                    <set field="shipToAddress.phone" from="shipToPhoneDetails"/>

                    <!-- Preparing trackingUrl -->
                    <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                        Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                        in HC like - partyId.toLowerCase + '.trackingUrl' -->
                    <set field="trackingUrl" value=""/>
                    <set field="orderShipmentCarrier" from="orderShipment.actualCarrierCode ? orderShipment.actualCarrierCode.toLowerCase() : orderShipment.carrierPartyId?.toLowerCase()"/>
                    <if condition="orderShipmentCarrier">
                        <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                            <field-map field-name="systemResourceId" from="orderShipmentCarrier"/>
                            <field-map field-name="systemPropertyId" from="orderShipmentCarrier + '.trackingUrl'"/>
                        </entity-find-one>

                        <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                        <if condition="systemProperty">
                            <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:orderShipment.trackingNumber])"/>
                        </if>
                    </if>

                    <!-- Fetch all Shipment items level details to prepare the Shipment Item list -->
                    <entity-find entity-name="co.hotwax.warehouse.OrderItemAndShipment" list="orderItemList">
                        <econdition field-name="orderId" from="fulfilledOrder.orderId"/>
                        <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                        <!-- Completed order items with 'DIGITAL_GOOD' product types,such product types are completed but no shipments are created.
                        because digital type order items are not fulfilled. So if we use econdition with shipmentStatusId ='SHIPMENT_SHIPPED',
                        then we will missed digital types order items.So for also including the digital type goods we use the or-null="true" attribute.
                        If shipmentStatusId is null then compare with the null value and fetch the record accordingly. -->
                        <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED" or-null="true"/>
                        <econdition field-name="isPhysical" ignore-if-empty="true"/>
                        <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                        <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                        <!-- The conditions below needs to be added as we have grouped order shipments based
                            on these fields above, and now we want to fetch shipment items for each shipment. -->
                        <econdition field-name="trackingNumber" from="orderShipment.trackingNumber"/>
                        <econdition field-name="actualCarrierCode" from="orderShipment.actualCarrierCode"/>
                        <econdition field-name="carrierPartyId" from="orderShipment.carrierPartyId"/>
                        <econdition field-name="shipmentMethodTypeId" from="orderShipment.shipmentMethodTypeId"/>
                        <econdition field-name="shipToContactMechId" from="orderShipment.shipToContactMechId"/>
                        <econdition field-name="shipToTelecomContactMechId" from="orderShipment.shipToTelecomContactMechId"/>
                        <having-econditions>
                            <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                            this can be needed where we want to ignore some historical data which is not required to sync. -->
                            <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                        </having-econditions>
                        <order-by field-name="statusDatetime"/>
                    </entity-find>

                    <iterate list="orderItemList" entry="orderItem">

                        <!-- Get all Good Identifications for Product -->
                        <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                            <econdition field-name="productId" from="orderItem.productId"/>
                            <date-filter/>
                        </entity-find>

                         <!-- Prepare the OrderItemAdjustment List -->
                        <set field="orderItemAdjustmentsList" from="orderAdjustmentList.findAll({orderItem.orderItemSeqId.equals(it.orderItemSeqId)})"/>

                        <!-- Prepare the OrderItemAttribute List -->
                        <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAttribute" list="orderItemAttributeList">
                            <econdition field-name="orderId" from="orderItem.orderId"/>
                            <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                        </entity-find>

                        <!-- There may be scenario when only a few facilities from all the facilities set-up are being used for external fulfillment.
                         For this, separate Facility Group could be created for such facilities, eg. Facility Group for NetSuite Fulfillment.
                         There could be further requirement to send orders to the external system which are fulfilled to the facilities belonging to a specific Facility Group eg. NetSuite Fulfillment.
                         In the HC Fulfilled Order Items Feed, all the facility group members of the fulfilled facility will be fetched.
                         In the Jolt Transform, order items can be further filtered out on the basis of Facility Group Id to send order items of a particular Facility Group.
                         TODO: For now we are using Facility Group Id for such checks, NOTE that Facility Group Type is not being used as the Facility Group Id will always be unique here, If needed in future, we can create view using FacilityGroup and FacilityGroupMember entities to include Facility Group type info as well. -->
                        <entity-find entity-name="org.apache.ofbiz.product.facility.FacilityGroupMember" list="facilityGroupMemberList">
                            <date-filter/>
                            <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        </entity-find>

                        <!-- NOTE: Removed the code for Kit Product handling as now on the Shipment will be created for Kit as well as for its components,
                            So no need to get the tracking details from the components and prepare a separate shipment map for kit type products -->

                            <!-- Prepare the shipment Item details -->
                            <set field="shipmentItemDetail" from="orderItem.getMap() +
                                [goodIdentifications:goodIdentificationList, orderItemAdjustments:orderItemAdjustmentsList, orderItemAttributes:orderItemAttributeList, facilityGroupMembers:facilityGroupMemberList]"/>
                            <script>
                                shipmentItems.add(shipmentItemDetail)
                            </script>
                        <!-- 1. Previously, We used the ExternalFulfillmentOrderItem entity for history creation using the fields orderId,orderItemId,shipGroupId.
                             2. Now the change is done, we are using the OrderFulfillmentHistory entity for history creation using the fields orderId and orderItemSeqId.
                             3. The shipGroupSeqId is not available in OrderFulfillmentHistory entity, this could have created possible issue for the scenario of explode OFF partial fulfillment
                                of an order Item as in that case shipGroupSeqId can be same.
                             4. This will not be an issue as discussed, for this scenario, new orderItem will be created for the remaining quantity for that item. -->
                            <!-- Note - This is done as part of initial implementation approach to create the Feed history records inside the iterate.
                            TODO Explore how we can take limit while processing records, default can be 1000, it means we are generating feed for 1000 items,
                            in that way will manage mysql transactions properly. https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/46 -->
                            <!-- Create record of OrderFulfillmentHistory to keep logs for the Fulfilled Order and Items Feed -->
                            <service-call name="create#co.hotwax.integration.order.OrderFulfillmentHistory" in-map="[orderId:orderItem.orderId,
                                    orderItemSeqId:orderItem.orderItemSeqId, shipmentId:orderItem.shipmentId,
                                    comments:'Order Item sent as part of Fulfilled Items Feed', createdDate:nowDate,
                                    externalFulfillmentId:'_NA_']"/>
                    </iterate>
                    <!-- Check if the shipmentItems is not empty to prepare details. 
                         NOTE This check is added so that another shipment map is not prepared for the kit product and 
                         if any other item gets included in the shipment group which has no tracking details, this 
                         should not be clubbed with the kit product shipment group. -->
                    <if condition="!shipmentItems.isEmpty()">
                        <!-- Prepare the Shipment details -->
                        <set field="shipmentDetail" from="[trackingNumber:orderShipment.trackingNumber,
                            carrierPartyId:orderShipment.carrierPartyId,
                            actualCarrierCode:orderShipment.actualCarrierCode,
                            shipmentMethodTypeId:orderShipment.shipmentMethodTypeId,
                            trackingUrl:trackingUrl, shipTo:shipToAddress, shipmentItems:shipmentItems]"/>
                        <script>
                            shipments.add(shipmentDetail)
                        </script>
                    </if>

                </iterate>

                <!-- Set orderInfoMap to prepare some of the order level details from orderItem map -->
                <set field="orderInfoMap" from="[:]"/>
                <!-- The null check on orderItem is added to handle NPE for the scenario when items are completed but shipment is not marked as
                     SHIPMENT_SHIPPED, this has been encountered in HC while preparing the Fulfilled Items Feed. 
                     NOTE:
                     1. Without this check, the entire feed gets stuck as no handling for such scenario, when the issue may be with 
                        only few order items. This is because the shipments and its items are fetched using the shipment status
                        check on SHIPMENT_SHIPPED value.
                     2. With this check, the order items will not be prepared for this scenario but order level details will be 
                        prepared which may be helpful for quick analysis.
                     3. Separate report has been scheduled to alert for such orders where items are completed but the shipment could 
                        not be marked as SHIPMENT_SHIPPED.
                     4. The feed will log the message when no shipment found for the required shipment status, else it will prepare 
                        the items for which shipment is marked as SHIPMENT_SHIPPED.
                     5. The check is added on orderItem object instead of orderShipment object since the order level details are 
                        being prepared from the orderItem (all fields are selected from the view).
                     -->
                <if condition="orderItem"><then>
                    <!-- Get all Party Identifications for a partyId -->
                    <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                        <econdition field-name="partyId" from="orderItem.customerPartyId"/>
                    </entity-find>

                    <!-- Prepare the order details -->
                    <set field="orderInfoMap" from="[orderName:orderItem.orderName, orderDate:orderItem.orderDate,
                        orderStatusId:orderItem.orderStatusId, orderExternalId:orderItem.orderExternalId, entryDate:orderItem.entryDate, grandTotal:orderItem.grandTotal,
                        customerFirstName:orderItem.customerFirstName, customerLastName:orderItem.customerLastName,
                        currency:orderItem.currency, salesChannel:orderItem.salesChannel, customerPartyId:orderItem.customerPartyId]"/>
                </then><else>
                    <log message="Not preparing the order item details for the order ${fulfilledOrder.orderId}, since no shipment found with SHIPMENT_SHIPPED status for the order."/>
                    <continue/>
                </else>
                </if>

                <!-- Prepare the Order Detail map -->
                <set field="orderDetail" from="fulfilledOrder.getMap() + orderInfoMap + [isShippingChargesSent:isShippingChargesSent,
                    orderIdentifications:orderIdentificationList, orderAttributes:orderAttributesList,
                    customerPartyIdentifications:partyIdentificationList?:[], payments:orderPaymentPreferenceList, billTo:billToAddress,
                    orderAdjustments:orderAdjustmentsList, shipments:shipments]"/>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetail)
                </script>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.info("Error preparing fulfilled order items Feed file", e)
                }
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                    messageText:jsonFilePathRef, productStoreId:productStoreId, shopId:customParametersMap?.shopId]" out-map="fulfillmentFeedSysMsgOut"/>
            <return message="Completed Fulfilled Order Items Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${fulfillmentFeedSysMsgOut.systemMessageId}"/>
        </actions>
    </service>

    <!-- TODO: This service can be removed in future as in case of Partial Fulfillment in explode-off scenario a new order item will be created for remaining quantities of that item.
         The existing FulfilledOrderItemsFeed service can be reused when this change is made.
    NOTE: This service uses TransferOrderItemAndShipment view for both purposes to fetch eligible orders for the feed and fetch Transfer order fulfilled items
    Shipments details. This view joins Order Fulfillment History entity with shipment id as well to handle orders with multiple shipments.
    1. The item status check for ITEM_COMPLETED is removed from entity find of TransferOrderItemAndShipment to handle the case when all quantities of an item are not completed.
       The status of such item is not COMPLETED. Hence it will not be included in this feed to exclude the quantities of that item which are completed.
    2. The not-null with true check for shipment status is removed from entity find of TransferOrderItemAndShipment as digital goods are not to be included in this feed.-->
    <service verb="generate" noun="TransferOrderFulfilledItemsFeed" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Transfer Order Fulfilled Items Feed JSON order wise, each order containing shipments
            list which is generated by grouping order by trackingIdNumber, carrierPartyId,
            shipmentMethodTypeId and shipToContactMechId, each shipment containing its completed items.
        </description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID for generating the Transfer Order Fulfilled Items Feed.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Transfer Order Fulfilled Items Feed.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch the Transfer Order Fulfilled Items details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch Transfer Order Fulfilled item details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="orderStatusId">
                <description>
                    Parameter to fetch Transfer Order Fulfilled item details for a specific Order Status ID like ORDER_APPROVED, ORDER_COMPLETED etc.
                </description>
            </parameter>
            <parameter name="orderTypeId" default-value="TRANSFER_ORDER">
                <description>
                    The parameter fetches Transfer Order Fulfilled item details for a specific Order Type ID (e.g., SALES_ORDER, TRANSFER_ORDER).
                    If no value is passed, the default feed for TRANSFER_ORDER will be generated.
                </description>
            </parameter>
            <parameter name="sinceDate">
                <description>Parameter to fetch Transfer Order Fulfilled Items after a specified date.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Transfer Order Fulfilled Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - PHYSICAL_STORE,DISTRIBUTION_CENTER,VIRTUAL_FACILITY and for single value use - PHYSICAL_STORE.
                </description>
            </parameter>
            <parameter name="productTypeIds" type="List">
                <description>
                    List of product Type Ids for generating Transfer Order Fulfilled Items Feed.
                    For passing the Product Type Ids as list, add values like -
                    FINISHED_GOOD,DIGITAL_GOOD,DONATION and for single value use - FINISHED_GOOD.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product Store Ids for generating Transfer Order Fulfilled Items feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE
                    and for single value use - SM_STORE.
                </description>
            </parameter>
            <parameter name="isPhysical">
                <description>
                    For passing the IsPhysical values like
                    1. isPhysical = 'Y' - Include Physical good type items.
                    2. isPhysical = 'N' - Include all the type of goods excluding the Physical good type items.
                    3. If we are not passing anything in the isPhysical then all the type of goods will be
                    considered for the feed.
                </description>
            </parameter>
            <parameter name="includeSalesChannel" type="List">
                <description>
                    Parameter to fetch fulfilled order items for orders received from specific sales channels.
                    For passing the Sales Channel values as list, add values like - CSR_CHANNEL,WEB_CHANNEL
                    and for single value use - WEB_CHANNEL
                </description>
            </parameter>
            <parameter name="excludeSalesChannel" type="List">
                <description>
                    Parameter to fetch fulfilled order items excluding orders received from specific sales channels.
                    For passing the Sales Channel values as list, add values like - POS_CHANNEL,B2B_CHANNEL
                    and for single value use - POS_CHANNEL
                </description>
            </parameter>
            <parameter name="customParametersMap" type="Map">
                <description>
                    This map defines custom conditions to fetch Transfer Order Fulfilled Items, allowing flexibility to add new conditions dynamically. This parameter expects map in a specific format including suffixes like *_op for operators and *_ic for case-insensitivity. Eg. If we want to fetch orders bases on Shopify Shop set up i.e. orders for a particular shopId, we can add the map like {"shopId": "SMUS_SHOP"}.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Transfer Order Fulfilled Items Feed file of HotWax for parentFacilityTypeId ${parentFacilityTypeIds}, Order ${orderId}, at time ${nowDate}"/>

            <!-- Fetch all Orders from TransferOrderItemAndShipment view to be included in
            the Transfer Order Fulfilled Items Feed, select-field values for only order level details. -->
            <entity-find entity-name="co.hotwax.warehouse.TransferOrderItemAndShipment" list="fulfilledTransferOrdersItr">
                <search-form-inputs input-fields-map="customParametersMap" paginate="false"/>
                <econdition field-name="orderId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED"/>
                <econdition field-name="orderStatusId" ignore-if-empty="true"/>
                <econdition field-name="orderTypeId"/>
                <econdition field-name="isPhysical" ignore-if-empty="true"/>
                <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                <econdition field-name="productStoreId" operator="in" from="productStoreIds" ignore-if-empty="true"/>
                <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                <econdition field-name="salesChannel" operator="in" from="includeSalesChannel" ignore-if-empty="true"/>
                <econdition field-name="salesChannel" operator="not-in" from="excludeSalesChannel" ignore-if-empty="true"/>
                <having-econditions>
                    <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                    this can be needed where we want to ignore some historical data which is not required to sync. -->
                    <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                </having-econditions>
                <!-- Select-fields to first identify eligible orders for the feed  -->
                <select-field field-name="orderId,productStoreId"/>
                <order-by field-name="statusDatetime"/>
                <use-iterator/>
            </entity-find>


            <!-- If no orders in TransferOrderItemAndShipment, then don't generate the file -->
            <if condition="!fulfilledTransferOrdersItr.hasNext()">
                <script>fulfilledTransferOrdersItr.close()</script>
                <return message="No eligible orders for Fulfilled Transfer Order Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
              then set the productStoreId to a default value as the feed being generated contains the Transfer Order Fulfilled Items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <!-- Prepare Transfer Order Fulfilled Items JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                        [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                         productStoreId:productStoreId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the Transfer Order Fulfilled Items Feed file  -->
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets

                try {
                    //json file
                    File fulfilledTransferOrderItemsFeedFile = new File(jsonFilePath)
                    if (!fulfilledTransferOrderItemsFeedFile.parentFile.exists()) fulfilledTransferOrderItemsFeedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, fulfilledTransferOrderItemsFeedFile);
                         JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="fulfilledTransferOrdersItr" entry="fulfilledTransferOrder">
                <log message="Generating feed for the Transfer order ${fulfilledTransferOrder.orderId}"/>

                <!-- Set shipments List to add the shipment details map -->
                <set field="shipments" from="[]"/>

                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <!-- Fetch the Shipping Charges and Shipping Sales Tax from FulfilledOrderAdjustmentAndHistory View -->
                <!-- 1. This View is created for the purpose to maintain the Order level Adjustments history which are sent as part of Feed to external systems.
                     2. The condition on the view is such that we it will fetch Order level adjustments which are not sent to external systems.
                     3. NOTE: For now only Shipping Charges, Shipping Sales tax and Shipping Adjustment is considered as the Order level
                        Adjustments for which we are maintaining the history.-->
                <entity-find entity-name="co.hotwax.financial.FulfilledOrderAdjustmentAndHistory" list="fulfilledOrderAdjustmentHistoryList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" value="_NA_"/>
                    <econdition field-name="orderAdjustmentTypeId" operator="in" value="SHIPPING_CHARGES,SHIPPING_SALES_TAX,EXT_SHIP_ADJUSTMENT"/>
                    <select-field field-name="orderAdjustmentId,orderAdjustmentTypeId,orderId,amount"/>
                </entity-find>

                <!-- Default value of isShippingChargesSent variable is 'Y' -->
                <set field="isShippingChargesSent" value="Y"/>
                <!-- 1. Using the isShippingChargesSent field, Will identify the that shipping charges,shipping sales tax and shipping adjustment sent or not.
                     2. If isShippingChargesSent is 'Y', means shipping charges, shipping sales tax and shipping adjustment already send as part of feed.
                     3. if isShippingChargesSent is 'N', means shipping charges, shipping sales tax and shipping adjustment didn't send as part of feed.
                     4. In the FulfilledOrderAdjustmentAndHistory entity only eligible records will be appeared for order level adjustment.
                     5. If fulfilledOrderAdjustmentHistoryList is empty for an order that means order level adjustment, has been already sent in the last feed.
                     6. In this case, the isShippingChargesSent default value will send in the feed. -->
                <!-- Prepare the Order Adjustment level history for Shipping Charges, Shipping Sales Tax,shipping adjustment -->
                <iterate list="fulfilledOrderAdjustmentHistoryList" entry="fulfilledOrderAdjustmentHistory">
                    <set field="isShippingChargesSent" value="N"/>
                    <service-call name="create#co.hotwax.integration.order.FulfilledOrderAdjustmentHistory"
                            in-map="[orderAdjustmentId:fulfilledOrderAdjustmentHistory.orderAdjustmentId,
                            orderAdjustmentTypeId:fulfilledOrderAdjustmentHistory.orderAdjustmentTypeId,
                            orderId:fulfilledOrderAdjustmentHistory.orderId, createdDate:nowDate,
                            comments:'Order Adjustment sent as part of Transfer Order Fulfilled Items Feed']"/>
                </iterate>

                <!-- Prepare the Order level adjustments list -->
                <set field="orderAdjustmentsList" from="orderAdjustmentList.findAll({'_NA_'.equals(it.orderItemSeqId)})"/>

                <!-- Get all the Payment Preferences for the orderId Id -->
                <!-- 1. Condition added to exclude payment preferences for the statusId='PAYMENT_REFUNDED'
                        as it is not applicable for Transfer Order Fulfilled Items Feed.
                     2. For the Order Payment Preference list for the Transfer Order Fulfilled Items Feed, the scenarios
                        are identified when Order Payment Preference status is either Authorised or Settled.
                     3. The Settled Status is observed for the payment method types like Shop Pay Installment -->
                <!-- NOTE: The results are ordered by the createdDate to get the oldest payment preference record first in the list.
                     This is done to handle the scenario of multi-part payment, that will have multiple records of a statusId for a given
                     orderId. Further handling can be done in the custom transformations as required. -->
                <entity-find entity-name="co.hotwax.financial.OrderPaymentPreferenceAndType" list="orderPaymentPreferenceList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                    <econdition field-name="statusId" operator="not-equals" value="PAYMENT_REFUNDED"/>
                    <order-by field-name="createdDate"/>
                </entity-find>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="orderContactMechList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" operator="in" value="BILLING_LOCATION,BILLING_EMAIL,PHONE_BILLING,SHIPPING_EMAIL"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- If orderContactMechList then fetch the billTo details using the contactMechIds -->
                <if condition="orderContactMechList">
                    <set field="billToAddressContactMechId" from="orderContactMechList.find{ 'BILLING_LOCATION'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="billToEmailOrderContactMech" from="orderContactMechList.find{ 'BILLING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>
                    <set field="billToPhoneContactMechId" from="orderContactMechList.find{ 'PHONE_BILLING'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="shipToEmailOrderContactMech" from="orderContactMechList?.find{ 'SHIPPING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>

                    <if condition="billToAddressContactMechId">
                        <!-- Get the BillTo Postal Address Details -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                            <field-map field-name="contactMechId" from="billToAddressContactMechId"/>
                        </entity-find-one>
                    </if>

                    <if condition="billToEmailOrderContactMech">
                        <!-- Get the BillTo Email Address Details -->
                        <entity-find-related-one value-field="billToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="billToEmailContactMech"/>
                    </if>

                    <if condition="billToPhoneContactMechId">
                        <!-- Get the BillTo Phone Number Details -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="billToPhoneDetails">
                            <field-map field-name="contactMechId" from="billToPhoneContactMechId"/>
                        </entity-find-one>
                    </if>
                </if>

                <!-- Adding the Email and Phone number details to billTo Map -->
                <!-- ToDo: Improve the schema of the billTo details map to have address map for postal details. Linked the related
                            issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                <set field="billToAddress" from="billToAddressMap ? billToAddressMap.getMap() : [:] "/>
                <set field="billToAddress.email" from="billToEmailContactMech?.infoString"/>
                <set field="billToAddress.phone" from="billToPhoneDetails"/>

                <!-- Fetch all Order Identifications for the Order Id -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get order attributes details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAttribute" list="orderAttributesList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                </entity-find>

                <!-- Fetch all Shipment details to prepare the Shipment level and Shipment Item level list -->
                <!-- The Shipment level list will include Shipment details like trackingIdNumber,
                    carrierPartyId, shipmentMethodTypeId, shipToContactMechId and shipment items.
                    The orders are grouped by the four fields and then the Shipment Item level list is
                    prepared and will include item level details.
                    Here select-field includes shipment level details -->
                <entity-find entity-name="co.hotwax.warehouse.TransferOrderItemAndShipment" list="transferOrderShipmentList">
                    <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED"/>
                    <econdition field-name="isPhysical" ignore-if-empty="true"/>
                    <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                    <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                    <!-- The conditions above needs to be added for fetching the order shipments for the order -->
                    <having-econditions>
                        <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                        this can be needed where we want to ignore some historical data which is not required to sync. -->
                        <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                    </having-econditions>
                    <!-- Select-fields to now identify eligible order shipments for the order  -->
                    <select-field field-name="trackingNumber,carrierPartyId,actualCarrierCode,shipmentMethodTypeId,shipToContactMechId,shipToTelecomContactMechId"/>
                    <order-by field-name="statusDatetime"/>
                </entity-find>

                <iterate list="transferOrderShipmentList" entry="transferOrderShipment">

                    <!-- Set shipmentItems List to add the shipment Items map -->
                    <set field="shipmentItems" from="[]"/>

                    <!-- Prepare Ship To Address details using PostalAddressView -->
                    <!-- NOTE:
                        1. Preparing the Ship To Address from the contactMechId in Shipment only.
                        2. Shipments are created for physical type goods so for them contactMechId will be taken from Shipment.
                        3. For digital type goods there are no shipments. So, Ship To Address will not be prepared. -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                        <field-map field-name="contactMechId" from="transferOrderShipment.shipToContactMechId"/>
                    </entity-find-one>

                    <!-- Get the Email Address Details -->
                    <if condition="shipToEmailOrderContactMech">
                        <entity-find-related-one value-field="shipToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="shipToEmailContactMech"/>
                    </if>

                    <!-- Get the Phone Number Details -->
                    <!-- TODO: TelecomContactMechId is from shipment entity, this should be handled. If the TelecomContactMechId is not found in shipment entity
                                then it should be fetched from OrderItemShipGroup entity. The way it is done for postalContactMechId.
                                 Related issue link: https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/445 -->
                    <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="shipToPhoneDetails">
                        <field-map field-name="contactMechId" from="transferOrderShipment.shipToTelecomContactMechId"/>
                    </entity-find-one>

                    <!-- Adding the Email and Phone number details to shipTo Map -->
                    <!-- ToDo: Improve the schema of the shipTo details map to have address map for postal details. Linked the related
                                issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                    <set field="shipToAddress" from="shipToAddressMap ? shipToAddressMap?.getMap() : [:] "/>
                    <set field="shipToAddress.email" from="shipToEmailContactMech?.infoString"/>
                    <set field="shipToAddress.phone" from="shipToPhoneDetails"/>

                    <!-- Preparing trackingUrl -->
                    <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                        Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                        in HC like - partyId.toLowerCase + '.trackingUrl' -->
                    <set field="trackingUrl" value=""/>
                    <set field="orderShipmentCarrier" from="transferOrderShipment.actualCarrierCode ? transferOrderShipment.actualCarrierCode.toLowerCase() : transferOrderShipment.carrierPartyId?.toLowerCase()"/>
                    <if condition="orderShipmentCarrier">
                        <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                            <field-map field-name="systemResourceId" from="orderShipmentCarrier"/>
                            <field-map field-name="systemPropertyId" from="orderShipmentCarrier + '.trackingUrl'"/>
                        </entity-find-one>

                        <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                        <if condition="systemProperty">
                            <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:transferOrderShipment.trackingNumber])"/>
                        </if>
                    </if>

                    <!-- Fetch all Shipment items level details to prepare the Shipment Item list -->
                    <entity-find entity-name="co.hotwax.warehouse.TransferOrderItemAndShipment" list="orderItemList">
                        <econdition field-name="orderId" from="fulfilledTransferOrder.orderId"/>
                        <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED"/>
                        <econdition field-name="isPhysical" ignore-if-empty="true"/>
                        <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                        <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                        <!-- The conditions below needs to be added as we have grouped order shipments based
                            on these fields above, and now we want to fetch shipment items for each shipment. -->
                        <econdition field-name="trackingNumber" from="transferOrderShipment.trackingNumber"/>
                        <econdition field-name="actualCarrierCode" from="transferOrderShipment.actualCarrierCode"/>
                        <econdition field-name="carrierPartyId" from="transferOrderShipment.carrierPartyId"/>
                        <econdition field-name="shipmentMethodTypeId" from="transferOrderShipment.shipmentMethodTypeId"/>
                        <econdition field-name="shipToContactMechId" from="transferOrderShipment.shipToContactMechId"/>
                        <econdition field-name="shipToTelecomContactMechId" from="transferOrderShipment.shipToTelecomContactMechId"/>
                        <having-econditions>
                            <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                            this can be needed where we want to ignore some historical data which is not required to sync. -->
                            <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                        </having-econditions>
                        <order-by field-name="statusDatetime"/>
                    </entity-find>

                    <iterate list="orderItemList" entry="orderItem">

                        <!-- Get all Good Identifications for Product -->
                        <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                            <econdition field-name="productId" from="orderItem.productId"/>
                            <date-filter/>
                        </entity-find>

                        <!-- Prepare the OrderItemAdjustment List -->
                        <set field="orderItemAdjustmentsList" from="orderAdjustmentList.findAll({orderItem.orderItemSeqId.equals(it.orderItemSeqId)})"/>

                        <!-- Prepare the OrderItemAttribute List -->
                        <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAttribute" list="orderItemAttributeList">
                            <econdition field-name="orderId" from="orderItem.orderId"/>
                            <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                        </entity-find>

                        <!-- There may be scenario when only a few facilities from all the facilities set-up are being used for external fulfillment.
                         For this, separate Facility Group could be created for such facilities, eg. Facility Group for NetSuite Fulfillment.
                         There could be further requirement to send orders to the external system which are fulfilled to the facilities belonging to a specific Facility Group eg. NetSuite Fulfillment.
                         In the HC Transfer Order Fulfilled Items Feed, all the facility group members of the fulfilled facility will be fetched.
                         In the Jolt Transform, order items can be further filtered out on the basis of Facility Group Id to send order items of a particular Facility Group.
                         TODO: For now we are using Facility Group Id for such checks, NOTE that Facility Group Type is not being used as the Facility Group Id will always be unique here, If needed in future, we can create view using FacilityGroup and FacilityGroupMember entities to include Facility Group type info as well. -->
                        <entity-find entity-name="org.apache.ofbiz.product.facility.FacilityGroupMember" list="facilityGroupMemberList">
                            <date-filter/>
                            <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        </entity-find>

                        <!-- Added handling for Kit Product Order Item -->
                        <!-- 1. In HC, the productTypeId for kit product is MARKETING_PKG_PICK and for this product type's fulfillment,
                            its component product order items are fulfilled i.e. Shipment in HC is created for the component
                            order items and not the kit product order item, and so the tracking details need to be fetched from the
                            component shipment items. NOTE that the kit product order item is also marked as completed once
                            the components are fulfilled.
                            2. The details like trackingUrl, trackingNumber, carrierPartyId and the shipmentMethodTypeId is prepared for
                            the kit product order item by adding separate shipment group map in the HC JSON so that it can be handled
                            separately in the transforms for HC to Shopify fulfillment.  -->
                        <if condition="'MARKETING_PKG_PICK'.equals(orderItem.productTypeId)"><then>
                            <set field="marketingPkgPickItems" from="[]"/>

                            <!-- Fetch the shipment level details from OrderItemAssocAndShipment view like the carrierPartyId, trackingCode and shipmentMethodTypeId for the kit product. -->
                            <!-- NOTE: This view has the shipment details of the component order items associated with the kit product order item. -->
                            <entity-find entity-name="co.hotwax.warehouse.OrderItemAssocAndShipment" list="orderItemAssocAndShipmentList">
                                <econdition field-name="orderId" from="orderItem.orderId"/>
                                <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                                <econdition field-name="toOrderId" from="orderItem.orderId"/>
                                <econdition field-name="orderItemAssocTypeId" value="KIT_COMPONENT"/>
                            </entity-find>

                            <set field="orderItemAssocAndShipmentFirst" from="orderItemAssocAndShipmentList?.first"/>
                            <!-- Check if the first item exists, then prepare the shipment level details for that
                                kit product order item, else the shipment level details will be set null and trackingUrl will be empty string -->
                            <if condition="orderItemAssocAndShipmentFirst"><then>
                                <!-- Preparing trackingUrl -->
                                <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                                    Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                                    in HC like - partyId.toLowerCase + '.trackingUrl' -->
                                <set field="trackingUrl" value=""/>
                                <set field="orderItemAssocAndShipmentCarrier" from="orderItemAssocAndShipmentFirst.actualCarrierCode ? orderItemAssocAndShipmentFirst.actualCarrierCode.toLowerCase() : orderItemAssocAndShipmentFirst.carrierPartyId?.toLowerCase()"/>
                                <if condition="orderItemAssocAndShipmentCarrier">
                                    <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                                        <field-map field-name="systemResourceId" from="orderItemAssocAndShipmentCarrier"/>
                                        <field-map field-name="systemPropertyId" from="orderItemAssocAndShipmentCarrier + '.trackingUrl'"/>
                                    </entity-find-one>

                                    <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                                    <if condition="systemProperty">
                                        <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:orderItemAssocAndShipmentFirst.trackingNumber])"/>
                                    </if>
                                </if>
                            </then><else>
                                <log level="warn" message="Order Item record not found in OrderItemAssocAndShipment, not preparing Shipment level details for OrderId ${orderItem.orderId} and OrderItem ${orderItem.orderItemSeqId}"/>
                            </else></if>
                            <set field="shipmentItemDetail" from="orderItem.getMap() +
                                    [goodIdentifications:goodIdentificationList, orderItemAdjustments:orderItemAdjustmentsList, orderItemAttributes:orderItemAttributeList, facilityGroupMembers:facilityGroupMemberList]"/>

                            <script>
                                marketingPkgPickItems.add(shipmentItemDetail)
                            </script>

                            <!-- TODO: Prepare shipTo details for the ship group of kit products in HC JSON, for now setting it as null. -->
                            <set field="shipmentDetail" from="[trackingNumber:orderItemAssocAndShipmentFirst?.trackingNumber,
                                    carrierPartyId:orderItemAssocAndShipmentFirst?.carrierPartyId,
                                    actualCarrierCode:orderItemAssocAndShipmentFirst?.actualCarrierCode,
                                    shipmentMethodTypeId:orderItemAssocAndShipmentFirst?.shipmentMethodTypeId,
                                    trackingUrl:trackingUrl, shipTo:null, shipmentItems:marketingPkgPickItems]"/>

                            <script>
                                shipments.add(shipmentDetail)
                            </script>

                        </then><else>
                            <!-- This section is to prepare shipment item details for non-kit type order items -->
                            <!-- Prepare the shipment Item details -->
                            <set field="shipmentItemDetail" from="orderItem.getMap() +
                                [goodIdentifications:goodIdentificationList, orderItemAdjustments:orderItemAdjustmentsList, orderItemAttributes:orderItemAttributeList, facilityGroupMembers:facilityGroupMemberList]"/>
                            <script>
                                shipmentItems.add(shipmentItemDetail)
                            </script>
                        </else></if>
                        <!-- 1. Previously, We used the ExternalFulfillmentOrderItem entity for history creation using the fields orderId,orderItemId,shipGroupId.
                             2. Now the change is done, we are using the OrderFulfillmentHistory entity for history creation using the fields orderId and orderItemSeqId.
                             3. The shipGroupSeqId is not available in OrderFulfillmentHistory entity, this could have created possible issue for the scenario of explode OFF partial fulfillment
                                of an order Item as in that case shipGroupSeqId can be same.
                             4. This will not be an issue as discussed, for this scenario, new orderItem will be created for the remaining quantity for that item. -->
                        <!-- Note - This is done as part of initial implementation approach to create the Feed history records inside the iterate.
                        TODO Explore how we can take limit while processing records, default can be 1000, it means we are generating feed for 1000 items,
                        in that way will manage mysql transactions properly. https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/46 -->
                        <!-- Create record of OrderFulfillmentHistory to keep logs for the Fulfilled Order and Items Feed -->
                        <service-call name="create#co.hotwax.integration.order.OrderFulfillmentHistory" in-map="[orderId:orderItem.orderId,
                                    orderItemSeqId:orderItem.orderItemSeqId, shipmentId:orderItem.shipmentId,
                                    comments:'Order Item sent as part of Fulfilled Items Feed', createdDate:nowDate,
                                    externalFulfillmentId:'_NA_']"/>
                    </iterate>
                    <!-- Check if the shipmentItems is not empty to prepare details.
                         NOTE This check is added so that another shipment map is not prepared for the kit product and
                         if any other item gets included in the shipment group which has no tracking details, this
                         should not be clubbed with the kit product shipment group. -->
                    <if condition="!shipmentItems.isEmpty()">
                        <!-- Prepare the Shipment details -->
                        <set field="shipmentDetail" from="[trackingNumber:transferOrderShipment.trackingNumber,
                            carrierPartyId:transferOrderShipment.carrierPartyId,
                            actualCarrierCode:transferOrderShipment.actualCarrierCode,
                            shipmentMethodTypeId:transferOrderShipment.shipmentMethodTypeId,
                            trackingUrl:trackingUrl, shipTo:shipToAddress, shipmentItems:shipmentItems]"/>
                        <script>
                            shipments.add(shipmentDetail)
                        </script>
                    </if>

                </iterate>

                <!-- Set orderInfoMap to prepare some of the order level details from orderItem map -->
                <set field="orderInfoMap" from="[:]"/>
                <!-- The null check on orderItem is added to handle NPE for the scenario when items are completed but shipment is not marked as
                     SHIPMENT_SHIPPED, this has been encountered in HC while preparing the Fulfilled Items Feed.
                     NOTE:
                     1. Without this check, the entire feed gets stuck as no handling for such scenario, when the issue may be with
                        only few order items. This is because the shipments and its items are fetched using the shipment status
                        check on SHIPMENT_SHIPPED value.
                     2. With this check, the order items will not be prepared for this scenario but order level details will be
                        prepared which may be helpful for quick analysis.
                     3. Separate report has been scheduled to alert for such orders where items are completed but the shipment could
                        not be marked as SHIPMENT_SHIPPED.
                     4. The feed will log the message when no shipment found for the required shipment status, else it will prepare
                        the items for which shipment is marked as SHIPMENT_SHIPPED.
                     5. The check is added on orderItem object instead of transferOrderShipment object since the order level details are
                        being prepared from the orderItem (all fields are selected from the view).
                     -->
                <if condition="orderItem"><then>
                    <!-- Get all Party Identifications for a partyId -->
                    <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                        <econdition field-name="partyId" from="orderItem.customerPartyId"/>
                    </entity-find>

                    <!-- Prepare the order details -->
                    <set field="orderInfoMap" from="[orderName:orderItem.orderName, orderDate:orderItem.orderDate,
                        orderStatusId:orderItem.orderStatusId, orderExternalId:orderItem.orderExternalId, entryDate:orderItem.entryDate, grandTotal:orderItem.grandTotal,
                        customerFirstName:orderItem.customerFirstName, customerLastName:orderItem.customerLastName,
                        currency:orderItem.currency, salesChannel:orderItem.salesChannel, customerPartyId:orderItem.customerPartyId]"/>
                </then><else>
                    <log message="Not preparing the order item details for the order ${fulfilledTransferOrder.orderId}, since no shipment found with SHIPMENT_SHIPPED status for the order."/>
                    <continue/>
                </else>
                </if>

                <!-- Prepare the Order Detail map -->
                <set field="orderDetail" from="fulfilledTransferOrder.getMap() + orderInfoMap + [isShippingChargesSent:isShippingChargesSent,
                    orderIdentifications:orderIdentificationList, orderAttributes:orderAttributesList,
                    customerPartyIdentifications:partyIdentificationList?:[], payments:orderPaymentPreferenceList, billTo:billToAddress,
                    orderAdjustments:orderAdjustmentsList, shipments:shipments]"/>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetail)
                </script>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.info("Error preparing transfer order fulfilled items Feed file", e)
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                          in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                    messageText:jsonFilePathRef, productStoreId:productStoreId]" out-map="fulfillmentFeedSysMsgOut"/>
            <return message="Completed Transfer Order Fulfilled Items Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${fulfillmentFeedSysMsgOut.systemMessageId}"/>
        </actions>
    </service>

    <service verb="check" noun="IsResidentialAddress">
        <description>
            Service to check if the address is residential or not.
            If Contact Mech Purpose Type Id with value 'WORK_LOCATION' exists, then the service returns 'N'.
            Else the service returns 'Y'.
        </description>
        <in-parameters>
            <parameter name="contactMechId">
                <description>Contact Mech Id of the order.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="isResidentialAddress">
                <description>This will return 'Y' if it is a residential address, else returns 'N'.</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- Default value of isResidentialAddress is kept 'Y' -->
            <!-- NOTE: Default value of isResidentialAddress is kept 'Y' because if we don't receive any data for residential address, in HC by default it is stored as 'Y' -->
            <set field="isResidentialAddress" value="Y"/>

            <!-- Checking if the contact Mech Purpose Type Id with value WORK_LOCATION exists or not  -->
            <entity-find-count entity-name="org.apache.ofbiz.order.order.OrderContactMech" count-field="workLocationCount">
                <econdition field-name="contactMechPurposeTypeId" value="WORK_LOCATION"/>
                <econdition field-name="contactMechId"/>
            </entity-find-count>
            
            <!-- If Work Location Count is greater than 0, isResidentialAddress is set to 'N' -->
            <if condition="workLocationCount &gt; 0">
                <set field="isResidentialAddress" value="N"/>
            </if>
        </actions>
    </service>

    <!-- TODO: As for now service call is anonymous-all, check to add the required authentication to provide the security on the service call -->
    <service verb="get" noun="Orders" authenticate="anonymous-all" transaction-timeout="1800">
        <description>Service to get the Order Details from HC.</description>
        <in-parameters>
            <parameter name="orderId">
                <description>The unique ID for the order in OMS.</description>
            </parameter>
            <parameter name="orderName">
                <description>The order name.</description>
            </parameter>
            <!-- TODO: Re-visit the code for pagination, for now used default view size as 20 -->
            <parameter name="viewIndex" type="Integer" default-value="0">
                <description>The current view index to get the orders.</description>
            </parameter>
            <parameter name="viewSize" type="Integer" default-value="20">
                <description>The maximum number of orders to display.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="orders" type="List">
                <parameter name="orderInfo" type="Map">
                    <parameter name="orderId">
                        <description>The unique ID assigned for the order in the system.</description>
                    </parameter>
                    <parameter name="orderName">
                        <description>The name of the Order.</description>
                    </parameter>
                    <parameter name="currency">
                        <description>The code describing the currency UOM of the order.</description>
                    </parameter>
                    <parameter name="salesChannelEnumId">
                        <description>The sales channel Id from where the order originated.</description>
                    </parameter>
                    <parameter name="salesChannelEnumCode">
                        <description>The sales channel code from where the order originated.</description>
                    </parameter>
                    <parameter name="orderStatusId">
                        <description>The status ID of the order in the system.</description>
                    </parameter>
                    <parameter name="orderDate" type="Timestamp" format="yyyy-MM-dd\'T\'HH:mm:ssXXX">
                        <description>The date when the order was placed.</description>
                    </parameter>
                    <parameter name="orderExternalId">
                        <description>The unique ID for the order in the external system.</description>
                    </parameter>
                    <parameter name="orderTypeId">
                        <description>The type ID to identify the type of an Order in the system.</description>
                    </parameter>
                    <parameter name="grandTotal" type="BigDecimal">
                        <description>The total amount of the order.</description>
                    </parameter>
                    <parameter name="customer" type="Map">
                        <parameter name="partyId">
                            <description>The unique ID of the customer in the system.</description>
                        </parameter>
                        <parameter name="partyExternalId">
                            <description>The unique ID of the customer in the external system.</description>
                        </parameter>
                        <parameter name="customerFirstName">
                            <description>The first name of the customer.</description>
                        </parameter>
                        <parameter name="customerMiddleName">
                            <description>The middle name of the customer.</description>
                        </parameter>
                        <parameter name="customerLastName">
                            <description>The last name of the customer.</description>
                        </parameter>
                        <parameter name="email">
                            <description>The email ID of the customer.</description>
                        </parameter>
                    </parameter>
                    <parameter name="orderIdentifications" type="List">
                        <parameter name="orderIdentificationMap" type="Map">
                            <parameter name="orderIdentificationTypeId">
                                <description>The ID of the order Identification type.</description>
                            </parameter>
                            <parameter name="orderId">
                                <description>The unique ID assigned for the order in the system.</description>
                            </parameter>
                            <parameter name="idValue">
                                <description>The value of the order Identification type.</description>
                            </parameter>
                        </parameter>
                    </parameter>
                    <parameter name="payments" type="List">
                        <parameter name="paymentMap" type="Map">
                            <parameter name="orderId">
                                <description>The unique ID assigned for the order in the system.</description>
                            </parameter>
                            <parameter name="amount" type="BigDecimal">
                                <description>The payment amount for the order.</description>
                            </parameter>
                            <parameter name="paymentMethodTypeId">
                                <description>The payment method type ID associated with the order.</description>
                            </parameter>
                            <parameter name="paymentMethodDescription">
                                <description>The description of the payment method.</description>
                            </parameter>
                            <parameter name="returnId">
                                <description>The unique ID assigned for the return in the system.</description>
                            </parameter>
                            <parameter name="statusId">
                                <description>The status ID associated with the payment.</description>
                            </parameter>
                            <parameter name="paymentMethodCode">
                                <description>The code associated with the payment method.</description>
                            </parameter>
                            <parameter name="createdDate">
                                <description>The creation date of the payment.</description>
                            </parameter>
                        </parameter>
                    </parameter>
                    <parameter name="orderAdjustments" type="List">
                        <parameter name="orderAdjustmentMap" type="Map">
                            <!-- As per the discussion selected fields used for the out parameters of order adjustment details -->
                            <parameter name="orderId">
                                <description>The unique ID assigned for the order in the system.</description>
                            </parameter>
                            <parameter name="orderItemSeqId">
                                <description>The Sequence ID of the item for an order in the system.</description>
                            </parameter>
                            <parameter name="orderAdjustmentId">
                                <description>The unique ID assigned for the Order adjustment.</description>
                            </parameter>
                            <parameter name="orderAdjustmentTypeId">
                                <description>The ID of the Order Adjustment Type.</description>
                            </parameter>
                            <parameter name="comments">
                                <description>The comments for the Order Adjustment.</description>
                            </parameter>
                            <parameter name="amount" type="BigDecimal">
                                <description>The amount for the Order Adjustment.</description>
                            </parameter>
                            <parameter name="sourcePercentage">
                                <description>The source percentage of the Order Adjustment.</description>
                            </parameter>
                        </parameter>
                    </parameter>
                    <parameter name="billTo" type="Map">
                        <description>The billing address for the order.</description>
                        <parameter name="contactMechId">
                            <description>The unique ID of the contactMech for the address in the system.</description>
                        </parameter>
                        <parameter name="toName">
                            <description>The customer's name for the address.</description>
                        </parameter>
                        <parameter name="address1">
                            <description>The address line 1 of the address.</description>
                        </parameter>
                        <parameter name="address2">
                            <description>The address line 2 of the address.</description>
                        </parameter>
                        <parameter name="city">
                            <description>The city of the address.</description>
                        </parameter>
                        <parameter name="stateProvinceGeoCode">
                            <description>The ID for the state code of the address in the system.</description>
                        </parameter>
                        <parameter name="countryCode">
                            <description>The ID for the country code of the address in the system.</description>
                        </parameter>
                        <parameter name="postalCode">
                            <description>The postal code of the address.</description>
                        </parameter>
                        <parameter name="phone" type="Map">
                            <description>The billing phone details for the order.</description>
                            <parameter name="contactMechId">
                                <description>The unique ID of the ContactMech for the phone in the system.</description>
                            </parameter>
                            <parameter name="countryCode">
                                <description>The country code of the contact number.</description>
                            </parameter>
                            <parameter name="contactNumber">
                                <description>The contact number of the customer.</description>
                            </parameter>
                            <parameter name="areaCode">
                                <description>The area code of the contact number.</description>
                            </parameter>
                        </parameter>
                    </parameter>
                    <parameter name="orderItems" type="List">
                        <description>The list of Order Items.</description>
                        <parameter name="orderItemMap" type="Map">
                            <parameter name="orderId">
                                <description>The unique ID assigned for the order in the system.</description>
                            </parameter>
                            <parameter name="orderItemSeqId">
                                <description>The Sequence ID of the Order Item in the system.</description>
                            </parameter>
                            <parameter name="facilityId">
                                <description>The ID of the facility in the system assigned to the order.</description>
                            </parameter>
                            <parameter name="carrierPartyId">
                                <description>The ID of the carrier service party in the system for the order.</description>
                            </parameter>
                            <parameter name="shipmentMethodTypeId">
                                <description>The shipment method type ID in the system for the order.</description>
                            </parameter>
                            <parameter name="statusId">
                                <description>The status ID of the Order item.</description>
                            </parameter>
                            <parameter name="productId">
                                <description>The ID of the product in the system.</description>
                            </parameter>
                            <parameter name="productName">
                                <description>The name of the product.</description>
                            </parameter>
                            <parameter name="quantity" type="Integer">
                                <description>The quantity of the product.</description>
                            </parameter>
                            <parameter name="unitPrice" type="BigDecimal">
                                <description>The unit amount of the product.</description>
                            </parameter>
                            <parameter name="parentProductName">
                                <description>The parent product name of the product in the system.</description>
                            </parameter>
                            <parameter name="parentProductId">
                                <description>The parent product ID.</description>
                            </parameter>
                            <parameter name="productTypeId">
                                <description>The product type ID.</description>
                            </parameter>
                            <parameter name="taxCode">
                                <description>The tax code of order item.</description>
                            </parameter>
                            <parameter name="orderItemExternalId">
                                <description>The external ID associated with the order item.</description>
                            </parameter>
                            <parameter name="shipTo" type="Map">
                                <description>The shipping address for the order.</description>
                                <parameter name="contactMechId">
                                    <description>The unique ID of the ContactMech for the address in the system.</description>
                                </parameter>
                                <parameter name="toName">
                                    <description>The customer's name for the address.</description>
                                </parameter>
                                <parameter name="address1">
                                    <description>The address line 1 of the address.</description>
                                </parameter>
                                <parameter name="address2">
                                    <description>The address line 2 of the address.</description>
                                </parameter>
                                <parameter name="city">
                                    <description>The city of the address.</description>
                                </parameter>
                                <parameter name="stateProvinceGeoCode">
                                    <description>The ID for the state code of the address in the system.</description>
                                </parameter>
                                <parameter name="countryCode">
                                    <description>The ID for the country code of the address in the system.</description>
                                </parameter>
                                <parameter name="postalCode">
                                    <description>The postal code of the address.</description>
                                </parameter>
                                <parameter name="phone" type="Map">
                                    <description>The shipping phone details for the order.</description>
                                    <parameter name="contactMechId">
                                        <description>The unique ID of the ContactMech for the phone in the system.</description>
                                    </parameter>
                                    <parameter name="countryCode">
                                        <description>The country code of the contact number.</description>
                                    </parameter>
                                    <parameter name="contactNumber">
                                        <description>The contact number of the customer.</description>
                                    </parameter>
                                    <parameter name="areaCode">
                                        <description>The area code of the contact number.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="productIdentifications" type="List">
                                <description>The list of productIdentifications in the items.</description>
                                <parameter name="productIdentificationsMap" type="Map">
                                    <!-- As per the discussion selected fields used for the out parameters of Product Identification details -->
                                    <parameter name="goodIdentificationTypeId">
                                        <description>The ID of the Good Identification Type for the product.</description>
                                    </parameter>
                                    <parameter name="productId">
                                        <description>The unique ID of the product.</description>
                                    </parameter>
                                    <parameter name="idValue">
                                        <description>The value of the Good Identification Type.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="orderItemAdjustments" type="List">
                                <!-- As per the discussion selected fields used for the out parameters of item adjustment details -->
                                <parameter name="orderItemAdjustmentMap" type="Map">
                                    <parameter name="orderId">
                                        <description>The unique ID assigned for the order in the system.</description>
                                    </parameter>
                                    <parameter name="orderItemSeqId">
                                        <description>The Sequence ID of the item for an order in the system.</description>
                                    </parameter>
                                    <parameter name="orderAdjustmentId">
                                        <description>The unique ID assigned for the Order adjustment.</description>
                                    </parameter>
                                    <parameter name="orderAdjustmentTypeId">
                                        <description>The ID of the Order Adjustment Type.</description>
                                    </parameter>
                                    <parameter name="comments">
                                        <description>The comments for the Order Adjustment.</description>
                                    </parameter>
                                    <parameter name="amount">
                                        <description>The amount for the Order Adjustment.</description>
                                    </parameter>
                                    <parameter name="sourcePercentage">
                                        <description>The source percentage of the Order Adjustment.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="productFeatures" type="List">
                                <!-- As per the discussion selected fields used for the out parameters of item productFeatures details -->
                                <parameter name="productFeatureMap" type="Map">
                                    <parameter name="productFeatureId">
                                        <description>The product feature ID associated with the product.</description>
                                    </parameter>
                                    <parameter name="productFeatureApplTypeId">
                                        <description>The product's Feature Application Type ID.</description>
                                    </parameter>
                                    <parameter name="productFeatureCategoryId">
                                        <description>The product Feature Category ID of product.</description>
                                    </parameter>
                                    <parameter name="description">
                                        <description>The product description.</description>
                                    </parameter>
                                    <parameter name="productFeatureTypeId">
                                        <description>The product's Feature Type ID.</description>
                                    </parameter>
                                    <parameter name="productId">
                                        <description>The unique identifier D associated with the product.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="electronicText" type="Map">
                                <description>The details of the Image URL for the products.</description>
                                <parameter name="productId">
                                    <description>The unique identifier ID associated with the product.</description>
                                </parameter>
                                <parameter name="productContentTypeId">
                                    <description>The product content type ID.</description>
                                </parameter>
                                <parameter name="contentName">
                                    <description>The name of the content.</description>
                                </parameter>
                                <parameter name="dataResourceId">
                                    <description>The ID of the data resource.</description>
                                </parameter>
                                <parameter name="dataResourceTypeId">
                                    <description>The type ID of the data resource.</description>
                                </parameter>
                                <parameter name="contentTypeId">
                                    <description>The type ID of the content.</description>
                                </parameter>
                                <parameter name="textData">
                                    <description>The textual data for the image URL.</description>
                                </parameter>
                                <parameter name="contentId">
                                    <description>The ID associated with the content.</description>
                                </parameter>
                            </parameter>
                            <parameter name="orderItemRole" type="List">
                                <parameter name="orderItemRoleMap" type="Map">
                                    <parameter name="orderId">
                                        <description>The unique ID assigned for the order in the system.</description>
                                    </parameter>
                                    <parameter name="orderItemSeqId">
                                        <description>The Sequence ID of the item for an order in the system.</description>
                                    </parameter>
                                    <parameter name="partyId">
                                        <description>The ID associated with the party.</description>
                                    </parameter>
                                    <parameter name="roleTypeId">
                                        <description>The type ID associated with the role.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                        </parameter>
                    </parameter>
                    <parameter name="returnItems" type="List">
                        <description>The list of return Item.</description>
                        <parameter name="returnItemInfoMap" type="Map">
                            <parameter name="returnId">
                                <description>The ID associated with the return.</description>
                            </parameter>
                            <parameter name="returnItemSeqId">
                                <description>The Sequence ID of the return Item in the system.</description>
                            </parameter>
                            <parameter name="orderId">
                                <description>The ID associated with the order.</description>
                            </parameter>
                            <parameter name="orderItemSeqId">
                                <description>The Sequence ID of the Order Item in the system.</description>
                            </parameter>
                            <parameter name="returnItemPrice" type="BigDecimal">
                                <description>The price associated with the return item.</description>
                            </parameter>
                            <parameter name="returnQuantity" type="Integer">
                                <description>The quantity of items being returned.</description>
                            </parameter>
                            <parameter name="returnReasonId">
                                <description>The ID associated with the return reason.</description>
                            </parameter>
                            <parameter name="productId">
                                <description>The unique identifier ID associated with the product.</description>
                            </parameter>
                            <parameter name="orderItemRequestedShipMethTypeId">
                                <description>The requested shipping method type ID for the order item.</description>
                            </parameter>
                            <parameter name="facilityId">
                                <description>The ID associated with the facility in the system.</description>
                            </parameter>
                            <parameter name="productStoreExternalId">
                                <description>The external ID associated with the product store.</description>
                            </parameter>
                            <parameter name="currency">
                                <description>The code describing the currency UOM of the order.</description>
                            </parameter>
                            <parameter name="customerPartyId">
                                <description>The ID associated with the customer party.</description>
                            </parameter>
                            <parameter name="productIdentifications" type="List">
                                <description>The list of productIdentifications in the items.</description>
                                <!-- As per the discussion selected fields used for the out parameters of Product Identification details -->
                                <parameter name="productIdentificationsMap" type="Map">
                                    <parameter name="goodIdentificationTypeId">
                                        <description>The ID of the Good Identification Type for the product.</description>
                                    </parameter>
                                    <parameter name="productId">
                                        <description>The unique ID of the product.</description>
                                    </parameter>
                                    <parameter name="idValue">
                                        <description>The value of the Good Identification Type.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="returnItemAdjustments" type="List">
                                <!-- As per the discussion selected fields used for the out parameters of return item adjustment details -->
                                <parameter name="returnItemAdjustmentMap" type="Map">
                                    <parameter name="returnId">
                                        <description>The unique ID assigned for the order in the system.</description>
                                    </parameter>
                                    <parameter name="returnItemSeqId">
                                        <description>The The Sequence ID of the item for an order in the system.</description>
                                    </parameter>
                                    <parameter name="returnAdjustmentId">
                                        <description>The unique ID assigned for the Order adjustment.</description>
                                    </parameter>
                                    <parameter name="returnAdjustmentTypeId">
                                        <description>The ID of the Order Adjustment Type.</description>
                                    </parameter>
                                    <parameter name="comments">
                                        <description>The comments for the Order Adjustment.</description>
                                    </parameter>
                                    <parameter name="amount" type="BigDecimal">
                                        <description>The amount for the Order Adjustment.</description>
                                    </parameter>
                                    <parameter name="sourcePercentage">
                                        <description>The source percentage of the Order Adjustment.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="productFeatures" type="List">
                                <parameter name="productFeatureMap" type="Map">
                                    <!-- As per the discussion selected fields used for the out parameters of product Features details -->
                                    <parameter name="productFeatureId">
                                        <description>The product Feature Id of product.</description>
                                    </parameter>
                                    <parameter name="productFeatureApplTypeId">
                                        <description>The product Feature Appl Type ID of product.</description>
                                    </parameter>
                                    <parameter name="productFeatureCategoryId">
                                        <description>The product Feature Category ID of product.</description>
                                    </parameter>
                                    <parameter name="description">
                                        <description>The description of product.</description>
                                    </parameter>
                                    <parameter name="productFeatureTypeId">
                                        <description>The product Feature Type ID of product.</description>
                                    </parameter>
                                    <parameter name="productId">
                                        <description>The product ID of product.</description>
                                    </parameter>
                                </parameter>
                            </parameter>
                            <parameter name="electronicText" type="Map">
                                <description>The details of the Image URL for the products.</description>
                                <parameter name="productId">
                                    <description>The unique identifier ID associated with the product.</description>
                                </parameter>
                                <parameter name="productContentTypeId">
                                    <description>The product content type ID.</description>
                                </parameter>
                                <parameter name="contentName">
                                    <description>The name of the content.</description>
                                </parameter>
                                <parameter name="dataResourceId">
                                    <description>The ID of the data resource.</description>
                                </parameter>
                                <parameter name="dataResourceTypeId">
                                    <description>The type ID of the data resource.</description>
                                </parameter>
                                <parameter name="contentTypeId">
                                    <description>The type ID of the content.</description>
                                </parameter>
                                <parameter name="textData">
                                    <description>The textual data for the image URL.</description>
                                </parameter>
                                <parameter name="contentId">
                                    <description>The ID associated with the content.</description>
                                </parameter>
                            </parameter>
                        </parameter>
                    </parameter>
                </parameter>
            </parameter>
        </out-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating the HotWax Get Order API response for Order ${orderId} at the time ${nowDate}."/>

            <!-- Fetch orders from the OrderItemDetail to identify those ready for preparation in the Get Order API format. -->
            <entity-find entity-name="co.hotwax.order.OrderItemDetail" list="ordersItr" offset="viewIndex * viewSize" limit="viewSize" >
                <econdition field-name="orderId" ignore-if-empty="true"/>
                <econdition field-name="orderName" ignore-if-empty="true"/>
                <select-field field-name="orderId,orderName,currency,salesChannelEnumId,salesChannelEnumCode,orderStatusId,orderDate,orderExternalId,orderTypeId,grandTotal"/>
                <use-iterator/>
            </entity-find>

            <!-- If there are no orders in the OrderItemDetail, skip the preparation of the Get Order API Response. -->
            <if condition="!ordersItr.hasNext()">
                <script>ordersItr.close()</script>
                <return message="No eligible orders at ${nowDate}."/>
            </if>

            <!-- List of all Orders -->
            <set field="orders" from="[]"/>

            <iterate list="ordersItr" entry="order">

                <!-- Fetch the Customer Party ID for the order with roleTypeId = 'BILL_TO_CUSTOMER' -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderRole" list="billToCustomerMap">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="roleTypeId" value="BILL_TO_CUSTOMER"/>
                    <date-filter/>
                </entity-find>

                <!-- Fetch Customer details from the PartyDetailView View -->
                <entity-find-one entity-name="org.apache.ofbiz.party.party.PartyDetailView" value-field="customerPartyMap">
                    <field-map field-name="partyId" from="billToCustomerMap?.partyId"/>
                </entity-find-one>

                <!-- Fetch all Order Identifications for the Order ID -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get order attributes details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAttribute" list="orderAttributeList">
                    <econdition field-name="orderId" from="order.orderId"/>
                </entity-find>

                <!-- Get all the Payment Preferences for an orderId. -->
                <entity-find entity-name="co.hotwax.financial.OrderPaymentPreferenceAndType" list="orderPaymentPreferenceList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <order-by field-name="createdDate"/>
                </entity-find>

                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="orderItemSeqId" value="_NA_"/>
                    <select-field field-name="orderId,orderAdjustmentTypeId,amount,orderAdjustmentId"/>
                </entity-find>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing and shipping details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="orderContactMechList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" operator="in" value="BILLING_LOCATION,BILLING_EMAIL,PHONE_BILLING,SHIPPING_EMAIL,ORDER_EMAIL"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- If orderContactMechList then fetch the billTo and shipTo details using the contactMechIds -->
                <if condition="orderContactMechList">
                    <set field="billToAddressContactMechId" from="orderContactMechList.find{ 'BILLING_LOCATION'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="billToPhoneContactMechId" from="orderContactMechList.find{ 'PHONE_BILLING'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="billToEmailContactMechId" from="orderContactMechList.find{ 'BILLING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>
                    <set field="shipToEmailContactMechId" from="orderContactMechList?.find{ 'SHIPPING_EMAIL'.equals(it.contactMechPurposeTypeId)}"/>
                    <set field="orderEmailContactMechId" from="orderContactMechList?.find{ 'ORDER_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>

                    <!-- If billToAddressContactMechId exist prepare the billTo Address details. -->
                    <if condition="billToAddressContactMechId">
                        <!-- Get the BillTo Postal Address Details -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                            <field-map field-name="contactMechId" from="billToAddressContactMechId"/>
                        </entity-find-one>
                    </if>

                    <!-- If billToPhoneContactMechId exist prepare the billTo Phone details. -->
                    <if condition="billToPhoneContactMechId">
                        <!-- Get the BillTo Phone Number Details -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="billToPhoneMap">
                            <field-map field-name="contactMechId" from="billToPhoneContactMechId"/>
                        </entity-find-one>
                    </if>

                    <!-- If billToEmailContactMechId exist prepare the billTo Email details. -->
                    <if condition="billToEmailContactMechId">
                        <!-- Get the BillTo Email Address Details -->
                        <entity-find-related-one value-field="billToEmailContactMechId" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="billToEmailContactMech"/>
                    </if>
                </if>

                <!-- Adding Phone number details to billTo Map -->
                <set field="billToAddress" from="billToAddressMap ? billToAddressMap.getMap() : [:] "/>
                <set field="billToAddress.email" from="billToEmailContactMech?.infoString"/>
                <set field="billToAddress.phone" from="billToPhoneMap"/>

                <!-- Preparing the details of the Customer -->
                <set field="customerDetails" from="[partyId:customerPartyMap?.partyId,
                    partyExternalId:customerPartyMap?.externalId, customerFirstName:customerPartyMap?.firstName,
                    customerMiddleName:customerPartyMap?.middleName, customerLastName:customerPartyMap?.lastName, email:billToEmailContactMech?.infoString]"/>

                <!-- TODO: Currently using operator in to fetch Return Items of multiple status
                    To avoid the use of in operator, we can use StatusType to manage lifecycle of the Object.
                    Check this note here: https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/merge_requests/475#note_199897 -->
                <!-- Fetch the Return Item details from the ReturnItemView. -->
                <!-- NOTE: The result of the below entity find will be used to fetch the details for Completed Return Items, as well as to prepare the Order and Item Fulfillment Status. -->
                <entity-find entity-name="co.hotwax.financial.ReturnItemView" list="returnItemList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="returnItemStatusId" operator="in" value="RETURN_COMPLETED,RETURN_RECEIVED"/>
                    <select-field field-name="orderId,productId,returnQuantity,orderItemRequestedShipMethTypeId,returnItemPrice,currencyUom,taxCode,orderItemExternalId,facilityId"/>
                </entity-find>

                <!-- Fetch orders Items from the OrderItemDetail to identify those ready for preparation in the Get Order API format. -->
                <!-- NOTE: 1. This grouping is done to prepare the item list per product. So, even if explode ON, each object will be prepared per product.
                              For example, if a product is ordered in a quantity of 3, there will be 3 records in the OrderItem entity,
                              but the itemList will consist of a single record with a quantity of 3.
                           2. In the case of mixed cart orders, if a product is ordered in a quantity of 3 where 2 are fulfilled from a store and 1 is delivered online,
                              there will be 3 records in the OrderItem entity. However, in the itemList, there will be 2 records: one for in-store fulfillment with a quantity of 2,
                              and another for online delivery with a quantity of 1. -->
                <entity-find entity-name="co.hotwax.order.OrderItemDetail" list="orderItemList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <select-field field-name="orderId,orderItemSeqId,itemStatusId,productId,quantity,promisedDatetime,shipmentMethodTypeId,unitPrice,unitListPrice,taxCode,orderItemExternalId,shipToPostalContactMechId,carrierPartyId,shipToTelecomContactMechId,facilityId,orderFacilityId"/>
                </entity-find>

                <!-- List of all Order Items -->
                <set field="orderItems" from="[]"/>

                <iterate list="orderItemList" entry="orderItem">

                    <!-- Fetch the Parent Product details -->
                    <!-- NOTE: Parent Product details are not the generic data fields, here this is prepared as part of
                         integration with the external system Predict Spring, where the company uses the parent product name
                         as part of product identifier. -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.ProductAssocAndFrom" list="orderItemParentProductList">
                        <econdition field-name="productIdTo" from="orderItem.productId"/>
                        <econdition field-name="productAssocTypeId" value="PRODUCT_VARIANT"/>
                        <date-filter/>
                    </entity-find>
                    <set field="orderItemCompletedDatetime" />
                    <if condition="'ITEM_COMPLETED'.equals(orderItem.itemStatusId)">
                        <entity-find entity-name="org.apache.ofbiz.order.order.OrderStatus" list="itemStatusList">
                            <econdition field-name="orderId" from="order.orderId" />
                            <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId" />
                            <econdition field-name="statusId" value="ITEM_COMPLETED" />
                            <order-by field-name="-statusDatetime"/>
                        </entity-find>
                        <if condition="itemStatusList != null &amp;&amp; itemStatusList.size() > 0">
                            <set field="orderItemCompletedDatetime" from="ec.l10n.format(itemStatusList[0].statusDatetime, System.getProperty('default_date_time_format'))" />
                        </if>
                    </if>

                    <!-- Get the first record for the parentProduct map -->
                    <set field="orderItemParentProduct" from="orderItemParentProductList?.first"/>

                    <!-- Prepare Ship To Address details using PostalAddressView -->
                    <!-- NOTE: 1. Preparing the Ship To Address from the contactMechId in OrderItemShipGroup only. -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                        <field-map field-name="contactMechId" from="orderItem.shipToPostalContactMechId"/>
                    </entity-find-one>

                    <!-- Get the Email Address Details -->
                    <if condition="shipToEmailContactMechId">
                        <entity-find-related-one value-field="shipToEmailContactMechId" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="shipToEmailContactMech"/>
                    </if>

                    <!-- Get the Phone Number Details -->
                    <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="shipToPhoneMap">
                        <field-map field-name="contactMechId" from="orderItem.shipToTelecomContactMechId"/>
                    </entity-find-one>

                    <!-- Adding the Phone number details to shipTo Map -->
                    <set field="shipToAddress" from="shipToAddressMap ? shipToAddressMap?.getMap() : [:] "/>
                    <set field="shipToAddress.email" from="shipToEmailContactMech?.infoString"/>
                    <set field="shipToAddress.phone" from="shipToPhoneMap"/>

                    <!-- Get all Good Identifications for Product -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <date-filter/>
                        <!--  Selecting few fields, TODO: Add more fields in future as per the need -->
                        <select-field field-name="productId,goodIdentificationTypeId,idValue"/>
                    </entity-find>

                    <!-- Get the Order Item Level Adjustments -->
                    <!-- NOTE: Added the below conditions to fetch the Order Item Adjustments:
                            1. is-not-null check on orderAdjustmentId to exclude those records where the order adjustment
                               does not exist for an order item.
                            2. Added facilityId in the condition, this is required to avoid the grouping of the adjustments for the scenario where an order has multiple qty,
                               like 3 qty, all the items are brokered at the same facility but one item is rejected and brokered on the other facility in this case the orderItem list will have
                               2 objects, one object will have 2 qty and the another object will have 1 qty even the product is the same. -->
                    <entity-find entity-name="co.hotwax.order.OrderItemAdjustmentAndAttribute" list="orderItemAdjustmentsList">
                        <econdition field-name="orderId" from="orderItem.orderId"/>
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <econdition field-name="orderItemExternalId" from="orderItem.orderItemExternalId"/>
                        <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        <econdition field-name="orderAdjustmentId" operator="is-not-null"/>
                        <select-field field-name="orderId,orderAdjustmentTypeId,amount,productId,comments,exemptAmount,orderItemExternalId,attrName,attrValue,sourceReferenceId"/>
                    </entity-find>

                    <!-- Get Product Features for Product -->
                    <entity-find entity-name="co.hotwax.product.feature.ProductFeatureAndAppl" list="productFeatureAndApplList" cache="true">
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <econdition field-name="productFeatureApplTypeId" value="STANDARD_FEATURE"/>
                        <date-filter/>
                    </entity-find>

                    <!-- Fetch the IMAGE URL details from ProductContentAndInfo View -->
                    <!-- NOTE The imageUrl is prepared for the parent Product ID and not the variant -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.ProductContentAndInfo" list="parentProductImageList">
                        <econdition field-name="productId" from="orderItemParentProduct?.productId"/>
                        <econdition field-name="productContentTypeId" value="IMAGE"/>
                    </entity-find>

                    <!-- Get order item attributes to get information about Store associate -->
                    <entity-find entity-name="co.hotwax.financial.OrderItemAndAttribute" list="orderItemAttributes">
                        <econdition field-name="orderId" from="orderItem.orderId"/>
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <econdition field-name="orderItemExternalId" from="orderItem.orderItemExternalId"/>
                        <select-field field-name="orderId,productId,attrName,attrValue,orderItemExternalId"/>
                    </entity-find>

                    <!-- Get order item change details. -->
                    <!-- NOTE: This is the part of the custom requirement of external system like Predict Spring. OrderItemChange details is required to
                         differentiate if the Order Item is canceled while creating returns of Approved Items in the Predict Spring or the Item is auto canceled. -->
                    <entity-find entity-name="co.hotwax.order.OrderItemAndChange" list="orderItemChangeList">
                        <econdition field-name="orderId" from="orderItem.orderId"/>
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <econdition field-name="orderItemExternalId" from="orderItem.orderItemExternalId"/>
                        <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        <econdition field-name="reasonEnumId" value="PS_CANCELLATION"/>
                        <select-field field-name="orderId,productId,orderItemExternalId,reasonEnumId,quantity"/>
                    </entity-find>

                    <!-- Get the first from orderItemChangeList. -->
                    <set field="orderItemChangeFirst" from="orderItemChangeList?.first"/>

                    <!-- NOTE: The below handling is required in the scenario when an order has multiple items for the same product and some of the items are canceled from Predict Spring and the other items are completed or approved.
                        For example an order has 3 items, associated with the P1 product, 2 items are in approved and the other one is canceled from Predict Spring. In this case while grouping the items it will create an object with 3 qty
                        since the productId, orderItemExternalId and the facilityId will be the same for all these three items and as per the handling of the item fulfillment status the status will be populated as PROCESSING. -->
                    <if condition="orderItemChangeFirst">
                        <!-- If current order item quantity is less then the quantity of order item change then prepare a separate object for the canceled items and subtract the order item quantity from current order item object quantity.
                            NOTE: For the new object of the canceled items the itemFulfillmentStatus will be set as CANCELLED as these items are canceled from Predict Spring. -->
                        <if condition="orderItem.quantity &gt; orderItemChangeFirst.quantity">
                            <!-- Prepare a map for canceled order item. -->
                            <set field="orderItemMapOfCanceledItem" from="[orderId:orderItem.orderId, facilityId:orderItem.facilityId, carrierParty:orderItem.carrierPartyId,
                                    shipmentMethodTypeId:orderItem.shipmentMethodTypeId, itemFulfillmentStatus:'CANCELLED', productId:orderItem.productId, quantity:orderItemChangeFirst.quantity,
                                    orderFacilityId:orderItem.orderFacilityId, unitPrice:orderItem.unitPrice, unitListPrice:orderItem.unitListPrice, parentProductId:orderItemParentProduct?.productId,
                                    parentProductName:orderItemParentProduct?.productName, productTypeId:orderItemParentProduct?.productTypeId, taxCode:orderItem.taxCode,
                                    orderItemExternalId:orderItem.orderItemExternalId, shipTo:shipToAddress, productIdentifications:goodIdentificationList, orderItemAdjustments:orderItemAdjustmentsList,
                                    productFeatures:productFeatureAndApplList, imageUrl:parentProductImageList?.first?.textData, orderItemAttributes:orderItemAttributes, orderItemChangeList:orderItemChangeList]"/>

                            <!-- Subtract the order item change quantity from the current order item quantity. -->
                            <set field="orderItem.quantity" from="orderItem.quantity - orderItemChangeFirst.quantity"/>

                            <!-- NOTE: Here this is required to overwrite orderItemChangeList to avoid the preparation of orderItemChange details in the non canceled items.  -->
                            <set field="orderItemChangeList" from="[]"/>

                            <script>orderItems.add(orderItemMapOfCanceledItem)</script>
                        </if>
                    </if>

                    <!-- Preparing Order Item Fulfillment Status -->
                    <!-- TODO: As of now the item fulfillment status is prepared within the get orders service, for a dev delivery and testing. The recommended way is to prepare a
                               separate service and check the use of drools for calculating the item and order fulfillment statuses based on specific parameters. -->


                    <!-- NOTE: The Get Order API response is prepared based on the products of an order instead of the individual order items, hence the item fulfillment status
                        is calculated as per the status of the product.
                        Examples:-
                            1. If an order has multiple items, let's say 3 items with different products, then in the orderItemList
                               the quantity will be one for each product and the itemFulfillment status will be calculated as per the status of the individual product.
                            2. If an order contains 2 items of the same product, and both items are fulfilled from different sources e.g. one product is fulfilled from a physical store
                               and the other product is delivered online. Then the orderItemList will contain separate entries for each item.
                               Each product will have a quantity of one, and the item fulfillment status will be prepared based on the current status of the individual product.
                            3. If an order contains 2 items of the same product, also they are fulfilled from one source,
                               then in the orderItemList the quantity of the product will be counted as part of the product's quantity which means for this example the quantity will be 2
                               and the item Fulfillment status will be accordingly. -->
                    <entity-find entity-name="co.hotwax.order.OrderItemDetail" list="orderItemAndStatusList">
                        <econdition field-name="orderId" from="orderItem.orderId"/>
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <!-- Here the condition is added on the order item externalId as well, this required to calculate the correct status for the mixed cart type of orders. -->
                        <econdition field-name="orderItemExternalId" from="orderItem.orderItemExternalId"/>
                        <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        <select-field field-name="orderId,productId,orderItemSeqId,itemStatusId"/>
                    </entity-find>

                    <!-- Get the size of order item status list -->
                    <!-- NOTE: This list contains all the items along with their respective statuses, which can be APPROVED, RETURNED, COMPLETED, or CANCELED. -->
                    <set field="sizeOfItemStatusList" from="orderItemAndStatusList.size()"/>

                    <!-- Fetch the size of all the Approved items of an order. -->
                    <!-- NOTE: This list only contains the size of the items that are in the Approved status. -->
                    <set field="sizeOfApprovedItemList" from="orderItemAndStatusList.findAll({'ITEM_APPROVED'.equals(it.itemStatusId)}).size()"/>

                    <!-- Fetch the size of all the Completed items of an order. -->
                    <!-- NOTE: This list only contains the size of the items that are in the Completed status. -->
                    <set field="sizeOfCompletedItemList" from="orderItemAndStatusList.findAll({'ITEM_COMPLETED'.equals(it.itemStatusId)}).size()"/>

                    <!-- Fetch the size of all the Canceled items of an order. -->
                    <!-- NOTE: This list only contains the size of items that are in the Canceled status. -->
                    <set field="sizeOfCanceledItemList" from="orderItemAndStatusList.findAll({'ITEM_CANCELLED'.equals(it.itemStatusId)}).size()"/>

                    <!-- Set the initial status of the item fulfillment status. -->
                    <set field="itemFulfillmentStatus" value="PROCESSING"/>

                    <!-- Fetch Order Item Seq IDs from OrderItemDetail View for the orderItem being prepared based on the grouping of orderId, productId, orderItemExternalId  -->
                    <!-- TODO grouping on productId could be removed, use orderItemExternalId -->
                     <!-- NOTE: This is required to fetch the total quantity of the return Items in the scenario when the products are the same but returned at facilities different from fulfillment facilities. For this, orderItemSeqIds are important else no identifier to fetch the corresponding returns for the orderItem being prepared. -->
                    <entity-find entity-name="co.hotwax.order.OrderItemDetail" list="orderItemSeqIdList">
                        <econdition field-name="orderId" from="orderItem.orderId"/>
                        <econdition field-name="productId" from="orderItem.productId"/>
                        <econdition field-name="orderItemExternalId" from="orderItem.orderItemExternalId"/>
                        <econdition field-name="facilityId" from="orderItem.facilityId"/>
                        <select-field field-name="orderId,orderItemSeqId"/>
                    </entity-find>

                    <!-- Get OrderItemIds from orderItemSeqIdList. -->
                    <set field="orderItemSeqIds" from="orderItemSeqIdList*.orderItemSeqId"/>

                    <!-- Fetch return Items count from ReturnItem entity. -->
                    <!-- TODO: For now, used the return items count as a returned quantity since EXPLODE ON, NOTE this will not work for EXPLODE OFF scenario, need to revisit the code to compute the quantity of the return items since it will be summed in that case. -->
                     <entity-find-count entity-name="org.apache.ofbiz.order.return.ReturnItem" count-field="returnItemsCount">
                        <econdition field-name="orderId" from="orderItem.orderId"/>
                        <econdition field-name="orderItemSeqId" operator="in" from="orderItemSeqIds"/>
                         <econdition field-name="statusId" operator="in" value="RETURN_COMPLETED,RETURN_RECEIVED"/>
                    </entity-find-count>

                    <!-- If returnItems list exist then prepare the item fulfillment status. -->
                    <!-- 1. If the quantity of returned items equals the quantity of order items OR there are no canceled and approved order items,
                            then the item fulfillment status will be set to 'RETURNED'.
                            1.1. For example [1] and [2], the status will calculate for individual product if the product is returned the
                                 itemFulfillmentStatus will be set to as 'RETURNED'.
                            1.2  For example [3], if one item is canceled and the other is returned, then in the orderItemList the order
                                 item quantity will still be counted as 2, and the fulfillment status will be RETURNED. Ideally, in this scenario,
                                 the status should be PARTIALLY_CANCELED. However, the status of the canceled item will never be changed and due to this
                                 in the Get Orders API response The status will always be PARTIALLY_CANCELED. Which makes it challenging to identify
                                 the status of the other item since it can be RETURNED, COMPLETED, APPROVED, or CANCELED.
                         2. If the return Item Quantity is less than the order item quantity then the item fulfillment status will be PARTIALLY_REFUNDED.
                            2.1 For example [1] and [2] this scenario will not be applied since in both the scenarios all the product of
                                an order will have individual entries in the orderItemList.
                            2.2 For example [3], if one of the item has returned, then in the orderItemList the order item quantity will be counted as 2,
                                and the item fulfillment status will be as 'PARTIALLY_REFUNDED'. -->

                    <!-- If the returnItems list does not exist but the canceledItems list exist then prepare the item fulfillment status. -->
                    <!-- 3. If the size of canceled items equals to size of order items then the item fulfillment status will be CANCELLED.
                            3.1 For example [1] and [2], the item fulfillment status will be calculated as per the current status of the individual product.
                                If the product is canceled the status will be set to as CANCELED.
                            3.2 For example [3], the point [1.2] will be applied.
                         4. If the size of sizeOfCanceledItemList is less than the size of sizeOfApprovedItemList or the sizeOfCanceledItemList equals the size of
                            sizeOfApprovedItemList then the item fulfillment status will be PROCESSING.
                         5. If the product status doesn't match any of the above scenarios, and for example [3], if the number of completed items equals
                            the number of order items,then the status of the products will be marked as 'COMPLETED' for all three examples mentioned above.
                         6. If both the list returnItems and canceledItems doesn't exist and size of completed item status equals the size of item status
                            then the item fulfillment status will be set as 'COMPLETED'.
                         7. If size of completed item status is greater than zero and less than the size of item status list then the item fulfillment
                            status will be set to as 'PARTIALLY_COMPLETED', this scenario will be applied only for the example [3]. -->

                    <if condition="returnItemsCount">
                        <then>
                            <if condition="returnItemsCount == orderItem.quantity || (sizeOfCanceledItemList &gt; 0 &amp;&amp; !sizeOfApprovedItemList)">
                                <then>
                                    <set field="itemFulfillmentStatus" value="RETURNED"/>
                                </then>
                                <else-if condition="returnItemsCount &lt; orderItem.quantity">
                                    <set field="itemFulfillmentStatus" value="PARTIALLY_REFUNDED"/>
                                </else-if>
                            </if>
                        </then>
                        <!-- If sizeOfCanceledItemList exists then prepare the item fulfillment status accordingly. -->
                        <else-if condition="sizeOfCanceledItemList">
                            <if condition="sizeOfCanceledItemList == sizeOfItemStatusList">
                                <then>
                                    <set field="itemFulfillmentStatus" value="CANCELLED"/>
                                </then>
                                <else-if condition="sizeOfApprovedItemList &gt; 0">
                                    <set field="itemFulfillmentStatus" value="PROCESSING"/>
                                </else-if>
                                <else>
                                    <set field="itemFulfillmentStatus" value="COMPLETED"/>
                                </else>
                            </if>
                        </else-if>
                        <else>
                            <!-- If returnItems list does not exist then prepare the order item status accordingly. -->
                            <if condition="sizeOfCompletedItemList == sizeOfItemStatusList">
                                <then>
                                    <set field="itemFulfillmentStatus" value="COMPLETED"/>
                                </then>
                                <else-if condition="sizeOfCompletedItemList &gt; 0 &amp;&amp; sizeOfCompletedItemList &lt; sizeOfItemStatusList">
                                    <set field="itemFulfillmentStatus" value="PARTIALLY_COMPLETED"/>
                                </else-if>
                            </if>
                        </else>
                    </if>

                    <!-- TODO: check if productTypeId should be the variant of the product or it does not matter?
                            the product type of parent and its variants will be same only always? -->
                    <!-- Preparing the details of the Item -->
                    <!-- NOTE for imageUrl first map is taken to always return single image,
                         TODO update if required for multiple images -->
                    <!-- TODO productName not prepared, taking it from OI.itemDescription does not make sense, as
                          it is the parent product name only. -->

                    <set field="promisedDatetime" />
                    <if condition="orderItem.promisedDatetime">
                        <set field="promisedDatetime" from="ec.l10n.format(orderItem.promisedDatetime, System.getProperty('default_date_time_format'))" />
                    </if>
                    <set field="orderItemMap" from="[orderId:orderItem.orderId, itemStatus:orderItem.itemStatusId, itemCompletedDatetime:orderItemCompletedDatetime, facilityId:orderItem.facilityId, promisedDatetime:promisedDatetime, carrierParty:orderItem.carrierPartyId,
                         shipmentMethodTypeId:orderItem.shipmentMethodTypeId, itemFulfillmentStatus:itemFulfillmentStatus,
                         productId:orderItem.productId, quantity:orderItem.quantity, orderFacilityId:orderItem.orderFacilityId,
                         unitPrice:orderItem.unitPrice, unitListPrice:orderItem.unitListPrice, parentProductId:orderItemParentProduct?.productId, parentProductName:orderItemParentProduct?.productName,
                         productTypeId:orderItemParentProduct?.productTypeId, taxCode:orderItem.taxCode, orderItemExternalId:orderItem.orderItemExternalId, shipTo:shipToAddress,
                         productIdentifications:goodIdentificationList, orderItemAdjustments:orderItemAdjustmentsList,
                         productFeatures:productFeatureAndApplList, imageUrl:parentProductImageList?.first?.textData, orderItemAttributes:orderItemAttributes,orderItemChangeList:orderItemChangeList]"/>
                    <script>orderItems.add(orderItemMap)</script>
                </iterate>

                <!-- List of all Return Items -->
                <set field="returnItems" from="[]"/>

                <!-- Prepare the Return Item Details using the returnItemList List. -->
                <iterate list="returnItemList" entry="returnItem">

                    <!-- Get all Good Identifications for Product -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                        <econdition field-name="productId" from="returnItem.productId"/>
                        <date-filter/>
                    </entity-find>

                    <!-- Fetch all ReturnAdjustments to prepare the Return level and Return Item level adjustments list -->
                    <!-- The Return level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax etc.
                        The Return Item level adjustments will include adjustments like Item Sales Tax, Item Discount etc. -->
                    <!-- NOTE: Added the below conditions while fetching Return Adjustments:
                            1. Added facilityId in the condition, this is required to avoid the grouping of the adjustments for the scenario
                               where an order has multiple qty, like 3 qty, all the items are brokered at the same facility but one item is
                               rejected and brokered on the other facility in this case the orderItem list will have
                               2 objects, one object will have 2 qty and the another object will have 1 qty even the product is the same.
                            2. orderItemExternId is also included in the fields so that it is included in the return items grouping -->
                    <entity-find entity-name="co.hotwax.order.ReturnAdjustmentAndItem" list="returnItemAdjustmentsList">
                        <econdition field-name="orderId" from="returnItem.orderId"/>
                        <econdition field-name="productId" from="returnItem.productId"/>
                        <econdition field-name="orderItemExternalId" from="returnItem.orderItemExternalId"/>
                        <econdition field-name="returnFacilityId" from="returnItem.facilityId"/>
                        <econdition field-name="statusId" operator="in" value="RETURN_COMPLETED,RETURN_RECEIVED"/>
                        <select-field field-name="orderId,returnAdjustmentTypeId,amount,productId,orderItemExternalId"/>
                    </entity-find>

                    <!-- Fetch the Parent Product details -->
                    <!-- NOTE: Parent Product details are not the generic data fields, here this is prepared as part of
                         integration with the external system PS, where the company uses the parent product name
                         as part of product identifier. -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.ProductAssocAndFrom" list="returnItemParentProductList">
                        <econdition field-name="productIdTo" from="returnItem.productId"/>
                        <econdition field-name="productAssocTypeId" value="PRODUCT_VARIANT"/>
                        <date-filter/>
                    </entity-find>
                    <!-- Get the first record for the parentProduct map -->
                    <set field="returnItemParentProduct" from="returnItemParentProductList?.first"/>

                    <!-- Fetch the IMAGE URL details from ProductContentAndInfo View -->
                    <!-- NOTE The imageUrl is prepared for the parent Product ID and not the variant -->
                    <entity-find entity-name="org.apache.ofbiz.product.product.ProductContentAndInfo" list="returnProductImageList">
                        <econdition field-name="productId" from="returnItemParentProduct?.productId"/>
                        <econdition field-name="productContentTypeId" value="IMAGE"/>
                    </entity-find>

                    <!-- Get Product Features for Product -->
                    <entity-find entity-name="co.hotwax.product.feature.ProductFeatureAndAppl" list="productFeatureAndApplList" cache="true">
                        <econdition field-name="productId" from="returnItem.productId"/>
                        <econdition field-name="productFeatureApplTypeId" value="STANDARD_FEATURE"/>
                        <date-filter/>
                    </entity-find>

                    <!-- Fetch the latest Returned Date for Product. -->
                    <!-- NOTE: Here the returned date is fetched for the product that was most recently returned. This is custom requirement for the external system like Predict Spring. -->
                    <entity-find entity-name="co.hotwax.financial.ReturnItemView" list="returnedItemDateList">
                        <econdition field-name="orderId" from="returnItem.orderId"/>
                        <econdition field-name="productId" from="returnItem.productId"/>
                        <econdition field-name="returnItemStatusId" operator="in" value="RETURN_COMPLETED,RETURN_RECEIVED"/>
                        <select-field field-name="productId,returnDate"/>
                        <order-by field-name="-returnDate"/>
                    </entity-find>

                    <!-- Fetch the first date from the returnedItemDateList. -->
                    <set field="firstReturnedDate" from="returnedItemDateList?.first.returnDate"/>

                    <!-- Fetch shipmentMethodTypeId, itemFulfillmentStatus and orderFacilityId from orderItems list. -->
                    <!-- orderItems list is used to prepare the shipmentMethodTypeId, itemFulfillmentStatus and orderFacilityId to avoid the redundancy of the code. -->
                    <set field="returnItemDetails" from="orderItems.find({(returnItem.productId).equals(it.productId)})"/>

                    <!-- Preparing the details of the Return Item -->
                    <!-- NOTE for imageUrl first map is taken to always return single image,
                         TODO update if required for multiple images -->
                    <set field="returnItemInfoMap" from="[orderId:returnItem.orderId, returnedDate:firstReturnedDate,
                         returnItemPrice:returnItem.returnItemPrice, parentProductId:returnItemParentProduct?.productId,
                         parentProductName:returnItemParentProduct?.productName, productTypeId:returnItemParentProduct?.productTypeId,
                         returnQuantity:returnItem.returnQuantity, returnReasonId:returnItem.returnReasonId ,productId:returnItem.productId,
                         orderItemRequestedShipMethTypeId:returnItem.orderItemRequestedShipMethTypeId, facilityId:returnItem.facilityId,
                         currency:returnItem.currencyUom, productIdentifications:goodIdentificationList, taxCode:returnItem.taxCode,
                         shipmentMethodTypeId:returnItemDetails?.shipmentMethodTypeId, itemFulfillmentStatus:returnItemDetails?.itemFulfillmentStatus,
                         orderFacilityId:returnItemDetails?.orderFacilityId, returnItemAdjustments:returnItemAdjustmentsList, orderItemExternalId:returnItem.orderItemExternalId,
                         productFeatures:productFeatureAndApplList, imageUrl:returnProductImageList?.first?.textData, orderItemAttributes:returnItemDetails?.orderItemAttributes]"/>

                    <script>returnItems.add(returnItemInfoMap)</script>
                </iterate>

                <!-- Fetch eligible order items for return. -->
                <!-- NOTE: Added is-null check on return ID to fetch the order items that are not returned yet. -->
                <entity-find entity-name="co.hotwax.financial.OrderItemAndReturnItemView" list="eligibleItemsForReturn">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="returnId" operator="is-null"/>
                    <econdition field-name="orderItemStatus" value="ITEM_COMPLETED"/>
                    <select-field field-name="orderId,productId,quantity"/>
                </entity-find>

                <!-- List for all eligible order items for return. -->
                <set field="returnEligibleItems" from="[]"/>

                <iterate list="eligibleItemsForReturn" entry="eligibleItemForReturn">
                    <!-- Fetch details of the order item from the orderItems list. -->
                    <set field="eligibleItemDetails" from="orderItems.findAll({(eligibleItemForReturn.productId).equals(it.productId) &amp;&amp; ('PARTIALLY_REFUNDED'.equals(it.itemFulfillmentStatus) || 'COMPLETED'.equals(it.itemFulfillmentStatus) || 'PARTIALLY_COMPLETED'.equals(it.itemFulfillmentStatus))})"/>

                    <!-- Prepare the map of order item details for return eligible. -->
                    <iterate list="eligibleItemDetails" entry="eligibleItem">
                        <set field="eligibleItemMap" from="[orderId:eligibleItem.orderId, facilityId:eligibleItem.facilityId, carrierParty:eligibleItem.carrierPartyId,
                         shipmentMethodTypeId:eligibleItem.shipmentMethodTypeId, itemFulfillmentStatus:'COMPLETED',
                         productId:eligibleItem.productId, quantity:eligibleItemForReturn.quantity, orderFacilityId:eligibleItem.orderFacilityId,
                         unitPrice:eligibleItem.unitPrice, unitListPrice:eligibleItem.unitListPrice, parentProductId:eligibleItem.parentProductId, parentProductName:eligibleItem.parentProductName,
                         productTypeId:eligibleItem.productTypeId, taxCode:eligibleItem.taxCode, orderItemExternalId:orderItem.orderItemExternalId, shipTo:eligibleItem.shipTo, productIdentifications:eligibleItem.productIdentifications,
                         orderItemAdjustments:eligibleItem.orderItemAdjustments, productFeatures:eligibleItem.productFeatures, imageUrl:eligibleItem.imageUrl, orderItemAttributes:eligibleItem.orderItemAttributes]"/>

                        <!-- Prepare the returnEligibleItems list of order item for return eligible. -->
                        <script>returnEligibleItems.add(eligibleItemMap)</script>
                    </iterate>
                </iterate>

                <!-- Preparing Order Fulfillment Status -->
                <!-- TODO: As of now the item fulfillment status is prepared within the get orders service, for a dev delivery and testing. The recommended way is to prepare a
                        separate service and check the use of drools for calculating the item and order fulfillment statuses based on specific parameters. -->

                <entity-find entity-name="org.apache.ofbiz.order.order.OrderItem" list="orderItemStatusList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <select-field field-name="orderId,productId,orderItemSeqId,statusId"/>
                </entity-find>

                <!-- Get the details of the returned item status -->
                <!-- NOTE: Used ReturnItemView instead of ReturnItem entity to fetch the details of the returned items of an order,
                           this required for the grouping of the products. -->
                <entity-find entity-name="co.hotwax.financial.ReturnItemView" list="returnedItemStatusList">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <select-field field-name="orderId,productId,orderItemSeqId,returnItemStatusId"/>
                </entity-find>

                <!-- Get the size of the orderItems list. -->
                <set field="sizeOfOrderItemStatusList" from="orderItemStatusList.size()"/>

                <!-- Get the size of canceled order items. -->
                <set field="sizeOfCanceledOrderItems" from="orderItemStatusList.findAll({'ITEM_CANCELLED'.equals(it.statusId)}).size()"/>

                <!-- Get the size of completed order items. -->
                <set field="sizeOfCompletedOrderItems" from="orderItemStatusList.findAll({'ITEM_COMPLETED'.equals(it.statusId)}).size()"/>

                <!-- Get the size of returned order items. -->
                <set field="sizeOfReturnedOrderItems" from="returnedItemStatusList.findAll({'RETURN_COMPLETED'.equals(it.returnItemStatusId) || 'RETURN_RECEIVED'.equals(it.returnItemStatusId)}).size()"/>

                <set field="sizeOfApprovedOrderItems" from="orderItemStatusList.findAll({'ITEM_APPROVED'.equals(it.statusId)}).size()"/>

                <!-- Get the size of completed order items from the orderItems list. -->
                <set field="sizeOfFulfilledOrderItems" from="orderItems.findAll({'COMPLETED'.equals(it.itemFulfillmentStatus)}).size()"/>

                <!-- Get the size of  approve order items from the orderItems list. -->
                <set field="sizeOfProcessingOrderItems" from="orderItems.findAll({'PROCESSING'.equals(it.itemFulfillmentStatus)}).size()"/>

                <!-- Get the size of  partial refund order items from the orderItems list. -->
                <set field="sizeOfPartialRefundedOrderItems" from="orderItems.findAll({'PARTIALLY_REFUNDED'.equals(it.itemFulfillmentStatus)}).size()"/>

                <!-- Set the orderFulfillmentStatus as PROCESSING. -->
                <set field="orderFulfillmentStatus" value="PROCESSING"/>

                <!-- If returnItems list exist then prepare the order fulfillment status. -->
                <if condition="returnItems">
                    <then>
                        <!-- If the size of all the order item status equals the size of all the returned items then set the orderFulfillmentStatus as 'RETURNED'. -->
                        <if condition="sizeOfOrderItemStatusList == sizeOfReturnedOrderItems"><then>
                            <set field="orderFulfillmentStatus" value="RETURNED"/>
                        </then>
                            <!-- Else if the size of canceled order items is greater than zero and the size of fulfilled order item and approved order is empty then
                                 set the orderFulfillmentStatus as 'RETURNED'. -->
                            <else-if condition="!sizeOfFulfilledOrderItems &amp;&amp; sizeOfCanceledOrderItems &gt; 0 &amp;&amp; !sizeOfProcessingOrderItems &amp;&amp; sizeOfPartialRefundedOrderItems &lt; 0">
                                <set field="orderFulfillmentStatus" value="RETURNED"/>
                            </else-if>
                            <!-- Else set the orderFulfillmentStatus as 'PARTIALLY_REFUNDED'. -->
                            <else>
                                <set field="orderFulfillmentStatus" value="PARTIALLY_REFUNDED"/>
                            </else>
                        </if>
                    </then>
                    <!-- If the sizeOfCanceledOrderItems exist then prepare the order fulfillment status. -->
                    <else-if condition="sizeOfCanceledOrderItems">
                        <!-- If the sizeOfCanceledOrderItems equals the sizeOfOrderItemStatusList, that means all the items of an order is canceled, hence set orderFulfillmentStatus as 'CANCELLED'. -->
                        <if condition="sizeOfCanceledOrderItems == sizeOfOrderItemStatusList"><then>
                            <set field="orderFulfillmentStatus" value="CANCELLED"/>
                        </then><else>
                            <!-- If sizeOfApprovedOrderItems is greater than zero, that means one of the order item is in the approved status, hence set the orderFulfillmentStatus as 'PROCESSING'. -->
                            <if condition="sizeOfApprovedOrderItems &gt; 0"><then>
                                <set field="orderFulfillmentStatus" value="PROCESSING"/>
                            </then>
                                <!-- Else set the orderFulfillmentStatus as 'COMPLETED'. -->
                                <else>
                                    <set field="orderFulfillmentStatus" value="COMPLETED"/>
                                </else>
                            </if>
                        </else>
                        </if>
                    </else-if>
                    <else>
                        <!-- If sizeOfCompletedOrderItems is equals the sizeOfOrderItemStatusList, that means all the items of an order is in completed status, hence set the orderFulfillmentStatus as 'COMPLETED'. -->
                        <if condition="sizeOfCompletedOrderItems == sizeOfOrderItemStatusList">
                            <then>
                                <set field="orderFulfillmentStatus" value="COMPLETED"/>
                            </then>
                            <!-- Else if the sizeOfCompletedOrderItems is greater than zero and less than the sizeOfOrderItemStatusList, which means a few items are completed and few items are not completed,
                                 Hence set the orderFulfillmentStatus as 'PARTIALLY_COMPLETED'. -->
                            <else-if condition="sizeOfCompletedOrderItems &gt; 0 &amp;&amp; sizeOfCompletedOrderItems &lt; sizeOfOrderItemStatusList">
                                <set field="orderFulfillmentStatus" value="PARTIALLY_COMPLETED"/>
                            </else-if>
                        </if>
                    </else>
                </if>

                <!-- Preparing Order Date Epoch field. -->
                <!-- TODO: Check and prepare the date in NiFi instead of the service. -->
                <set field="orderDateEpoch" from="order.orderDate.toInstant().toEpochMilli()"/>

                <!-- Get the Order Email Details -->
                <if condition="orderEmailContactMechId">
                    <entity-find-related-one value-field="orderEmailContactMechId" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="orderEmailContactMech"/>
                </if>
                <set field="orderCompletedDatetime" />
                <if condition="'ORDER_COMPLETED'.equals(order.orderStatusId)">
                    <entity-find entity-name="org.apache.ofbiz.order.order.OrderStatus" list="orderStatusList">
                        <econdition field-name="orderId" from="order.orderId" />
                        <econdition field-name="statusId" value="ORDER_COMPLETED" />
                        <order-by field-name="-statusDatetime"/>
                    </entity-find>
                    <if condition="orderStatusList != null &amp;&amp; orderStatusList.size() > 0">
                        <set field="orderCompletedDatetime" from="ec.l10n.format(orderStatusList[0].statusDatetime, System.getProperty('default_date_time_format'))" />
                    </if>
                </if>

                <!-- Preparing Order Info Map -->
                <set field="orderInfoMap" from="[orderId:order.orderId, orderName:order.orderName,
                    currency:order.currency, salesChannelEnumId:order.salesChannelEnumId, salesChannelEnumCode:order.salesChannelEnumCode,
                    orderStatusId:order.orderStatusId, orderCompletedDatetime:orderCompletedDatetime, orderFulfillmentStatus:orderFulfillmentStatus, orderEmail:orderEmailContactMech?.infoString,
                    orderDate:ec.l10n.format(order.orderDate, 'yyyy-MM-dd\'T\'HH:mm:ssXXX'), orderDateEpoch:orderDateEpoch,
                    orderExternalId:order.orderExternalId, orderTypeId:order.orderTypeId, grandTotal:order.grandTotal, orderIdentifications:orderIdentificationList,
                    orderAttributes:orderAttributeList, payments:orderPaymentPreferenceList, orderAdjustments:orderAdjustmentList, customer:customerDetails,
                    billTo:billToAddress, orderItems:orderItems, returnItems:returnItems, returnEligibleItems:returnEligibleItems]"/>
                <script>
                    orders.add(orderInfoMap)
                </script>
            </iterate>
        </actions>
    </service>
    <service verb="search" noun="Orders" authenticate="anonymous-all" transaction-timeout="7200">
        <description>Service to search the Order Details from HC.</description>
        <in-parameters>
            <parameter name="responseMap" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="response" type="List"/>
        </out-parameters>
        <actions>
            <!-- Prepare the list of total orders received from the Solr API response. -->
            <set field="totalOrders" from="responseMap?.grouped?.orderId?.groups"/>

            <!-- List for the Orders. -->
            <set field="orders" from="[]"/>

            <!-- Get the remaining details of the order. -->
            <iterate list="totalOrders" entry="order">
                <!-- NOTE: Here the get#Orders service is used to fetch the remaining details of the order. This helps to avoid the redundancy of the code.
                 Specifically, when sending a response to external system like Predict Spring, it is crucial to include the status of each order.
                 In the Search Orders API response the order status relies on the current status of individual items within the order. Hence instead of duplicating the process of obtaining
                 item details here, the get#Orders service is used, which already handles retrieving all order details, including item and order statuses. -->
                <service-call name="co.hotwax.ofbiz.OrderServices.get#Orders" in-map="[orderId:order.groupValue]" out-map="orderDetails"/>
                <!-- Prepare the order details to send it in the API response. -->
                <iterate list="orderDetails.orders" entry="orderDetail">
                    <script>
                        orders.add(orderDetail)
                    </script>
                    <set field="response" from="orders"/>
                </iterate>
            </iterate>
        </actions>
    </service>

    <!-- The service will generate Fulfilled Order Items Feed Json for ERP.
         NOTE
            1. If no value is passed in orderStatusId, then the feed will fetch the eligible orders
               where the itemStatusId is 'ITEM_COMPLETED' as the default behavior.
            3. The format for the feed is order-level wise which contains shipments information and each
               shipment contains information for the completed items.
            4. For digital type goods, there is no Shipments involved, so for the order with digital and
               physical type items, separate shipment groups will be identified based on the field
               selection of trackingIdNumber, carrierPartyId, shipmentMethodTypeId and shipToContactMechId
               and each shipment will contain its completed items.
            5. A parameter, orderTypeId, is added to the Fulfilled Order Items Feed to accommodate various
               order types. If provided, the system generates a feed specific to the given order type;
               otherwise, it defaults to generating a feed for only sales orders. -->
    <service verb="generate" noun="FulfilledOrderItemsFeedForErp" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Fulfilled Order Items Feed for ERP. The feed format is a JSON.
            The JSON includes information order-wise with each order containing shipments
            list which is generated by grouping order by trackingIdNumber, carrierPartyId,
            shipmentMethodTypeId and shipToContactMechId, each shipment containing its completed items.
            This history entity used for the feed is OrderFulfillmentErpHistory which will contain records
            for the order items sent as part of this feed so that items are not sent multiple times
            to the external system.
        </description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID for generating the ERP Fulfilled Order Items Feed.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the ERP Fulfilled Order Items Feed.</description>
            </parameter>
            <parameter name="orderStatusId">
                <description>Parameter to fetch fulfilled order item details for a specific Order Status ID like ORDER_APPROVED, ORDER_COMPLETED etc.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch fulfilled order item details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch fulfilled order item details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="orderTypeId" default-value="SALES_ORDER">
                <description>
                    The parameter fetches fulfilled order item details for a specific Order Type ID (e.g., SALES_ORDER, TRANSFER_ORDER).
                    If no value is passed, the default feed for SALES_ORDER will be generated.
                </description>
            </parameter>
            <parameter name="sinceDate">
                <description>Parameter to fetch fulfilled order items after a specified date.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Fulfilled Order Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - PHYSICAL_STORE,DISTRIBUTION_CENTER,VIRTUAL_FACILITY and for single value use - PHYSICAL_STORE.
                </description>
            </parameter>
            <parameter name="productTypeIds" type="List">
                <description>
                    List of product Type Ids for generating Fulfilled Order Items Feed.
                    For passing the Product Type Ids as list, add values like -
                    FINISHED_GOOD,DIGITAL_GOOD,DONATION and for single value use - FINISHED_GOOD.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product Store Ids for generating Fulfilled orders item feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE
                    and for single value use - SM_STORE.
                </description>
            </parameter>
            <parameter name="isPhysical">
                <description>
                    For passing the IsPhysical values like
                    1. isPhysical = 'Y' - Include Physical good type items.
                    2. isPhysical = 'N' - Include all the type of goods excluding the Physical good type items.
                    3. If we are not passing anything in the isPhysical then all the type of goods will be
                    considered for the feed.
                </description>
            </parameter>
            <parameter name="includeSalesChannel" type="List">
                <description>
                    Parameter to fetch fulfilled order items for orders received from specific sales channels.
                    For passing the Sales Channel values as list, add values like - CSR_CHANNEL,WEB_CHANNEL
                    and for single value use - WEB_CHANNEL
                </description>
            </parameter>
            <parameter name="excludeSalesChannel" type="List">
                <description>
                    Parameter to fetch fulfilled order items excluding orders received from specific sales channels.
                    For passing the Sales Channel values as list, add values like - POS_CHANNEL,B2B_CHANNEL
                    and for single value use - POS_CHANNEL
                </description>
            </parameter>
            <parameter name="customParametersMap" type="Map">
                <description>
                    This map defines custom conditions to fetch Fulfilled Order Items, allowing flexibility to add new conditions dynamically. This parameter expects map in a specific format including suffixes like *_op for operators and *_ic for case-insensitivity. Eg. If we want to fetch orders bases on Shopify Shop set up i.e. orders for a particular shopId, we can add the map like {"shopId": "SMUS_SHOP"}.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating ERP Fulfilled Order Items Feed file at time ${nowDate}"/>

            <!-- Fetch all Orders from FulfilledOrderItemsForErp view to be included in
            the Fulfilled Order Items Feed, select-field values for only order level details -->
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                erpFulfilledOrders_find = ec.entity.find("co.hotwax.warehouse.FulfilledOrderItemsForErp")
                    .searchFormMap(customParametersMap, null, "", "", false)
                    .condition("itemStatusId", "ITEM_COMPLETED")
                    .condition("orderTypeId", orderTypeId)

                if(orderId) erpFulfilledOrders_find.condition("orderId", orderId)
                if(orderItemSeqId) erpFulfilledOrders_find.condition("orderItemSeqId", orderItemSeqId)
                if(orderStatusId) erpFulfilledOrders_find.condition("orderStatusId", orderStatusId)
                if(isPhysical) erpFulfilledOrders_find.condition("isPhysical", isPhysical)
                if(parentFacilityTypeIds) erpFulfilledOrders_find.condition("parentFacilityTypeId", EntityCondition.ComparisonOperator.IN, parentFacilityTypeIds)
                if(productStoreIds) erpFulfilledOrders_find.condition("productStoreId", EntityCondition.ComparisonOperator.IN, productStoreIds)
                if(productTypeIds) erpFulfilledOrders_find.condition("productTypeId", EntityCondition.ComparisonOperator.IN, productTypeIds)
                if(includeSalesChannel) erpFulfilledOrders_find.condition("salesChannel", EntityCondition.ComparisonOperator.IN, includeSalesChannel)
                if(excludeSalesChannel) erpFulfilledOrders_find.condition("salesChannel", EntityCondition.ComparisonOperator.NOT_IN, excludeSalesChannel)
                <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                this can be needed where we want to ignore some historical data which is not required to sync. -->
                if(sinceDate) erpFulfilledOrders_find.havingCondition(ec.entity.conditionFactory.makeCondition("statusDatetime", EntityCondition.ComparisonOperator.GREATER_THAN, sinceDate))
                <!-- Select-fields to first identify eligible orders for the feed  -->
                erpFulfilledOrders_find.selectField("orderId,productStoreId,shopId")
                .orderBy("statusDatetime")

                // Using try-with-resources to automatically close the EntityListIterator 'erpFulfilledOrdersItr'
                try (erpFulfilledOrdersItr = erpFulfilledOrders_find.iterator()) {
            </script>

            <!-- If no orders in FulfilledOrderItemsForErp, then don't generate the file -->
            <if condition="!erpFulfilledOrdersItr.hasNext()">
                <return message="No eligible orders for ERP Fulfilled Order Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
              then set the productStoreId to a default value as the feed being generated contains the Fulfilled order items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <!-- Prepare ERP fulfilled order items JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                productStoreId:productStoreId,shopId:customParametersMap?.shopId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the ERP Fulfilled Order Items Feed file  -->
            <script>
                try {
                    //json file
                    File erpFulfilledOrderItemsFeedFile = new File(jsonFilePath)
                    if (!erpFulfilledOrderItemsFeedFile.parentFile.exists()) erpFulfilledOrderItemsFeedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                    so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, erpFulfilledOrderItemsFeedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="erpFulfilledOrdersItr" entry="erpFulfilledOrder">
                <log message=" ======== Generating feed for the order ${erpFulfilledOrder.orderId} =========="/>

                <!-- Set shipments List to add the shipment details map -->
                <set field="shipments" from="[]"/>

                <!-- Fetch all OrderAdjustments to prepare the Order level and Item level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. and the Item level Adjustments will include adjustments like
                    Item Sales Tax, Item Discount etc. -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" value="_NA_"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount,orderAdjustmentId,originalAdjustmentId"/>
                </entity-find>

                <!-- Fetch the Shipping Charges and Shipping Sales Tax from FulfilledOrderAdjustmentAndHistory View -->
                <!-- 1. This View is created for the purpose to maintain the Order level Adjustments history which are sent as part of Feed to external systems.
                     2. The condition on the view is such that we it will fetch Order level adjustments which are not sent to external systems.
                     3. NOTE: For now only Shipping Charges, Shipping Sales tax and Shipping Adjustment is considered as the Order level
                        Adjustments for which we are maintaining the history.-->
                <entity-find entity-name="co.hotwax.financial.FulfilledOrderAdjustmentAndHistory" list="fulfilledOrderAdjustmentHistoryList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" value="_NA_"/>
                    <econdition field-name="orderAdjustmentTypeId" operator="in" value="SHIPPING_CHARGES,SHIPPING_SALES_TAX,EXT_SHIP_ADJUSTMENT"/>
                    <select-field field-name="orderAdjustmentId,orderAdjustmentTypeId,orderId,amount"/>
                </entity-find>

                <!-- Default value of isShippingChargesSent variable is 'Y' -->
                <set field="isShippingChargesSent" value="Y"/>
                <!-- 1. Using the isShippingChargesSent field, Will identify the that shipping charges,shipping sales tax and shipping adjustment sent or not.
                     2. If isShippingChargesSent is 'Y', means shipping charges, shipping sales tax and shipping adjustment already send as part of feed.
                     3. if isShippingChargesSent is 'N', means shipping charges, shipping sales tax and shipping adjustment didn't send as part of feed.
                     4. In the FulfilledOrderAdjustmentAndHistory entity only eligible records will be appeared for order level adjustment.
                     5. If fulfilledOrderAdjustmentHistoryList is empty for an order that means order level adjustment, has been already sent in the last feed.
                     6. In this case, the isShippingChargesSent default value will send in the feed. -->
                <!-- Prepare the Order Adjustment level history for Shipping Charges, Shipping Sales Tax,shipping adjustment -->
                <iterate list="fulfilledOrderAdjustmentHistoryList" entry="fulfilledOrderAdjustmentHistory">
                    <set field="isShippingChargesSent" value="N"/>
                    <service-call name="create#co.hotwax.integration.order.FulfilledOrderAdjustmentHistory"
                            in-map="[orderAdjustmentId:fulfilledOrderAdjustmentHistory.orderAdjustmentId,
                            orderAdjustmentTypeId:fulfilledOrderAdjustmentHistory.orderAdjustmentTypeId,
                            orderId:fulfilledOrderAdjustmentHistory.orderId, createdDate:nowDate,
                            comments:'Order Adjustment sent as part of Fulfilled Order Items Feed']"/>
                </iterate>

                <!-- Get all the Payment Preferences for the orderId Id -->
                <!-- 1. Condition added to exclude payment preferences for the statusId='PAYMENT_REFUNDED'
                        as it is not applicable for Fulfilled Order Items Feed.
                     2. For the Order Payment Preference list for the Fulfilled Order Items Feed, the scenarios
                        are identified when Order Payment Preference status is either Authorised or Settled.
                     3. The Settled Status is observed for the payment method types like Shop Pay Installment -->
                <!-- NOTE: The results are ordered by the createdDate to get the oldest payment preference record first in the list.
                     This is done to handle the scenario of multi-part payment, that will have multiple records of a statusId for a given
                     orderId. Further handling can be done in the custom transformations as required. -->
                <entity-find entity-name="co.hotwax.financial.OrderPaymentPreferenceAndType" list="orderPaymentPreferenceList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                    <econdition field-name="statusId" operator="not-equals" value="PAYMENT_REFUNDED"/>
                    <order-by field-name="createdDate"/>
                </entity-find>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="orderContactMechList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" operator="in" value="BILLING_LOCATION,BILLING_EMAIL,PHONE_BILLING,SHIPPING_EMAIL"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- If orderContactMechList then fetch the billTo details using the contactMechIds -->
                <if condition="orderContactMechList">
                    <set field="billToAddressContactMechId" from="orderContactMechList.find{ 'BILLING_LOCATION'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="billToEmailOrderContactMech" from="orderContactMechList.find{ 'BILLING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>
                    <set field="billToPhoneContactMechId" from="orderContactMechList.find{ 'PHONE_BILLING'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="shipToEmailOrderContactMech" from="orderContactMechList?.find{ 'SHIPPING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>

                    <if condition="billToAddressContactMechId">
                        <!-- Get the BillTo Postal Address Details -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                            <field-map field-name="contactMechId" from="billToAddressContactMechId"/>
                        </entity-find-one>
                    </if>

                    <if condition="billToEmailOrderContactMech">
                        <!-- Get the BillTo Email Address Details -->
                        <entity-find-related-one value-field="billToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="billToEmailContactMech"/>
                    </if>

                    <if condition="billToPhoneContactMechId">
                        <!-- Get the BillTo Phone Number Details -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="billToPhoneDetails">
                            <field-map field-name="contactMechId" from="billToPhoneContactMechId"/>
                        </entity-find-one>
                    </if>
                </if>

                <!-- Adding the Email and Phone number details to billTo Map -->
                <!-- ToDo: Improve the schema of the billTo details map to have address map for postal details. Linked the related
                            issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                <set field="billToAddress" from="billToAddressMap ? billToAddressMap.getMap() : [:] "/>
                <set field="billToAddress.email" from="billToEmailContactMech?.infoString"/>
                <set field="billToAddress.phone" from="billToPhoneDetails"/>

                <!-- Fetch all Order Identifications for the Order Id -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get order attributes details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAttribute" list="orderAttributeList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                </entity-find>

                <!-- Fetch all Shipment details to prepare the Shipment level and Shipment Item level list -->
                <!-- The Shipment level list will include Shipment details like trackingIdNumber,
                    carrierPartyId, shipmentMethodTypeId, shipToContactMechId and shipment items.
                    The orders are grouped by the four fields and then the Shipment Item level list is
                    prepared and will include item level details.
                    Here select-field includes shipment level details -->
                <entity-find entity-name="co.hotwax.warehouse.OrderItemShipmentForErp" list="orderShipmentList">
                    <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                    <!-- Completed order items with 'DIGITAL_GOOD' product types,such product types are completed but no shipments are created.
                    because digital type order items are not fulfilled. So if we use econdition with shipmentStatusId ='SHIPMENT_SHIPPED',
                    then we will missed digital types order items.So for also including the digital type goods we use the or-null="true" attribute.
                    If shipmentStatusId is null then compare with the null value and fetch the record accordingly. -->
                    <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED" or-null="true"/>
                    <econdition field-name="isPhysical" ignore-if-empty="true"/>
                    <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                    <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                    <!-- The conditions above needs to be added for fetching the order shipments for the order -->
                    <having-econditions>
                        <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                        this can be needed where we want to ignore some historical data which is not required to sync. -->
                        <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                    </having-econditions>
                    <!-- Select-fields to now identify eligible order shipments for the order  -->
                    <select-field field-name="trackingNumber,carrierPartyId,actualCarrierCode,shipmentMethodTypeId,shipToContactMechId,shipToTelecomContactMechId"/>
                    <order-by field-name="statusDatetime"/>
                </entity-find>

                <iterate list="orderShipmentList" entry="orderShipment">

                    <!-- Set shipmentItems List to add the shipment Items map -->
                    <set field="shipmentItems" from="[]"/>

                    <!-- Prepare Ship To Address details using PostalAddressView -->
                    <!-- NOTE:
                        1. Preparing the Ship To Address from the contactMechId in Shipment only.
                        2. Shipments are created for physical type goods so for them contactMechId will be taken from Shipment.
                        3. For digital type goods there are no shipments. So, Ship To Address will not be prepared. -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                        <field-map field-name="contactMechId" from="orderShipment.shipToContactMechId"/>
                    </entity-find-one>

                    <!-- Get the Email Address Details -->
                    <if condition="shipToEmailOrderContactMech">
                        <entity-find-related-one value-field="shipToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="shipToEmailContactMech"/>
                    </if>

                    <!-- Get the Phone Number Details -->
                    <!-- TODO: TelecomContactMechId is from shipment entity, this should be handled. If the TelecomContactMechId is not found in shipment entity
                                then it should be fetched from OrderItemShipGroup entity. The way it is done for postalContactMechId.
                                 Related issue link: https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/445 -->
                    <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="shipToPhoneDetails">
                        <field-map field-name="contactMechId" from="orderShipment.shipToTelecomContactMechId"/>
                    </entity-find-one>

                    <!-- Adding the Email and Phone number details to shipTo Map -->
                    <!-- ToDo: Improve the schema of the shipTo details map to have address map for postal details. Linked the related
                                issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                    <set field="shipToAddress" from="shipToAddressMap ? shipToAddressMap?.getMap() : [:] "/>
                    <set field="shipToAddress.email" from="shipToEmailContactMech?.infoString"/>
                    <set field="shipToAddress.phone" from="shipToPhoneDetails"/>

                    <!-- Preparing trackingUrl -->
                    <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                        Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                        in HC like - partyId.toLowerCase + '.trackingUrl' -->
                    <set field="trackingUrl" value=""/>
                    <set field="orderShipmentCarrier" from="orderShipment.actualCarrierCode ? orderShipment.actualCarrierCode.toLowerCase() : orderShipment.carrierPartyId?.toLowerCase()"/>
                    <if condition="orderShipmentCarrier">
                        <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                            <field-map field-name="systemResourceId" from="orderShipmentCarrier"/>
                            <field-map field-name="systemPropertyId" from="orderShipmentCarrier + '.trackingUrl'"/>
                        </entity-find-one>

                        <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                        <if condition="systemProperty">
                            <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:orderShipment.trackingNumber])"/>
                        </if>
                    </if>

                    <!-- Fetch all Shipped Order Items to prepare the Shipment Item list -->
                    <entity-find entity-name="co.hotwax.warehouse.OrderItemShipmentForErp" list="fulfilledItemList">
                        <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                        <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                        <!-- Completed order items with 'DIGITAL_GOOD' product types,such product types are completed but no shipments are created.
                        because digital type order items are not fulfilled. So if we use econdition with shipmentStatusId ='SHIPMENT_SHIPPED',
                        then we will missed digital types order items.So for also including the digital type goods we use the or-null="true" attribute.
                        If shipmentStatusId is null then compare with the null value and fetch the record accordingly. -->
                        <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED" or-null="true"/>
                        <econdition field-name="isPhysical" ignore-if-empty="true"/>
                        <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                        <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                        <!-- The conditions below needs to be added as we have grouped order shipments based
                            on these fields above, and now we want to fetch shipment items for each shipment. -->
                        <econdition field-name="trackingNumber" from="orderShipment.trackingNumber"/>
                        <econdition field-name="actualCarrierCode" from="orderShipment.actualCarrierCode"/>
                        <econdition field-name="carrierPartyId" from="orderShipment.carrierPartyId"/>
                        <econdition field-name="shipmentMethodTypeId" from="orderShipment.shipmentMethodTypeId"/>
                        <econdition field-name="shipToContactMechId" from="orderShipment.shipToContactMechId"/>
                        <econdition field-name="shipToTelecomContactMechId" from="orderShipment.shipToTelecomContactMechId"/>
                        <having-econditions>
                            <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                            this can be needed where we want to ignore some historical data which is not required to sync. -->
                            <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                        </having-econditions>
                        <select-field field-name="orderId,orderItemSeqId"/>
                        <order-by field-name="statusDatetime"/>
                    </entity-find>

                    <set field="orderItemSeqIdList" from="fulfilledItemList*.orderItemSeqId"/>

                    <!-- Call the core service to fetch the order items list as per HotWax JSON schema -->
                    <service-call name="co.hotwax.ofbiz.OrderServices.get#OrderItems"
                            in-map="[orderId:erpFulfilledOrder.orderId, orderItemSeqIds:orderItemSeqIdList]"
                            out-map="orderItemsOut"/>

                    <set field="shipmentItemList" from="orderItemsOut?.orderItems"/>

                    <!-- Added handling for Kit Product Order Item -->
                    <!-- 1. In HC, the productTypeId for kit product is MARKETING_PKG_PICK and for this product type's fulfillment,
                        its component product order items are fulfilled i.e. Shipment in HC is created for the component
                        order items and not the kit product order item, and so the tracking details need to be fetched from the
                        component shipment items. NOTE that the kit product order item is also marked as completed once
                        the components are fulfilled.
                        2. The details like trackingUrl, trackingNumber, carrierPartyId and the shipmentMethodTypeId is prepared for
                        the kit product order item by adding separate shipment group map in the HC JSON so that it can be handled
                        separately in the transforms for HC to Shopify fulfillment.  -->
                    <set field="shipmentItemProductTypeList" from="orderItemsOut?.orderItems*.productTypeId"/>

                    <if condition="shipmentItemProductTypeList.contains('MARKETING_PKG_PICK')"><then>

                        <!-- Case 1: Multiple Kit Products - same shipment
                             Case 2: Multiple Kit Products - different shipments
                             NOTE Handling is done to always create 1 shipment group for each kit product -->
                        <iterate list="shipmentItemList" entry="shipmentItem">
                            <!-- Fetch the shipment level details from OrderItemAssocAndShipment view like the carrierPartyId, trackingCode and shipmentMethodTypeId for the kit product. -->
                            <!-- NOTE: This view has the shipment details of the component order items associated with the kit product order item. -->
                            <entity-find entity-name="co.hotwax.warehouse.OrderItemAssocAndShipment" list="orderItemAssocAndShipmentList">
                                <econdition field-name="orderId" from="erpFulfilledOrder.orderId"/>
                                <econdition field-name="orderItemSeqId" from="shipmentItem.orderItemSeqId"/>
                                <econdition field-name="toOrderId" from="erpFulfilledOrder.orderId"/>
                                <econdition field-name="orderItemAssocTypeId" value="KIT_COMPONENT"/>
                            </entity-find>

                            <set field="orderItemAssocAndShipmentFirst" from="orderItemAssocAndShipmentList?.first"/>
                            <!-- Check if the first item exists, then prepare the shipment level details for that
                                kit product order item, else the shipment level details will be set null and trackingUrl will be empty string -->
                            <if condition="orderItemAssocAndShipmentFirst"><then>
                                <!-- Preparing trackingUrl -->
                                <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                                    Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                                    in HC like - partyId.toLowerCase + '.trackingUrl' -->
                                <set field="trackingUrl" value=""/>
                                <set field="orderItemAssocAndShipmentCarrier" from="orderItemAssocAndShipmentFirst.actualCarrierCode ? orderItemAssocAndShipmentFirst.actualCarrierCode.toLowerCase() : orderItemAssocAndShipmentFirst.carrierPartyId?.toLowerCase()"/>
                                <if condition="orderItemAssocAndShipmentCarrier">
                                    <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                                        <field-map field-name="systemResourceId" from="orderItemAssocAndShipmentCarrier"/>
                                        <field-map field-name="systemPropertyId" from="orderItemAssocAndShipmentCarrier + '.trackingUrl'"/>
                                    </entity-find-one>

                                    <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                                    <if condition="systemProperty">
                                        <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:orderItemAssocAndShipmentFirst.trackingNumber])"/>
                                    </if>
                                </if>
                            </then><else>
                                <log level="warn" message="Order Item record not found in OrderItemAssocAndShipment, not preparing Shipment level details for OrderId ${orderItem.orderId} and OrderItem ${orderItem.orderItemSeqId}"/>
                            </else></if>

                            <!-- TODO: Prepare shipTo details for the ship group of kit products in HC JSON, for now setting it as null. -->
                            <set field="shipmentDetail" from="[trackingNumber:orderItemAssocAndShipmentFirst?.trackingNumber,
                            carrierPartyId:orderItemAssocAndShipmentFirst?.carrierPartyId,
                            actualCarrierCode:orderItemAssocAndShipmentFirst?.actualCarrierCode,
                            shipmentMethodTypeId:orderItemAssocAndShipmentFirst?.shipmentMethodTypeId,
                            trackingUrl:trackingUrl, shipTo:null, shipmentItems:[shipmentItem]]"/>

                            <script>shipments.add(shipmentDetail)</script>
                        </iterate>
                    </then><else>
                        <set field="shipmentDetail" from="[trackingNumber:orderShipment.trackingNumber,
                            carrierPartyId:orderShipment.carrierPartyId,
                            actualCarrierCode:orderShipment.actualCarrierCode,
                            shipmentMethodTypeId:orderShipment.shipmentMethodTypeId,
                            trackingUrl:trackingUrl, shipTo:shipToAddress,
                            shipmentItems:shipmentItemList]"/>

                        <script>shipments.add(shipmentDetail)</script>
                    </else></if>

                    <!-- Create the history in OrderFulfillmentErpHistory for each shipment item included in the feed -->
                    <iterate list="shipmentItemList" entry="shipmentItem">
                        <!-- Create record of OrderFulfillmentErpHistory to keep logs for the Fulfilled Order and Items Feed for ERP -->
                        <service-call name="create#co.hotwax.integration.order.OrderFulfillmentErpHistory"
                                in-map="[orderId:shipmentItem.orderId, orderItemSeqId:shipmentItem.orderItemSeqId,
                                shipmentId:shipmentItem.shipmentId, createdDate:nowDate,
                                comments:'Order Item sent as part of Fulfilled Items Feed to ERP']"/>
                    </iterate>
                </iterate>

                <!-- Set orderInfoMap to prepare some of the order level details from orderItem map -->
                <set field="orderInfoMap" from="[:]"/>
                <!-- The null check on shipmentItemList is added to handle NPE for the scenario when items
                     are completed but shipment is not marked as SHIPMENT_SHIPPED.
                     This scenario is handled due to an issue encountered in HC OMS where status is not updated correctly.
                     NOTE:
                     1. Without this check, the entire feed gets stuck as no handling for such scenario, when the issue may be with
                        only few order items. This is because the shipments and its items are fetched using the shipment status
                        check on SHIPMENT_SHIPPED value.
                     2. With this check, the order items will not be prepared for this scenario but order level details will be
                        prepared which may be helpful for quick analysis.
                     3. Separate report has been scheduled to alert for such orders where items are completed but the shipment could
                        not be marked as SHIPMENT_SHIPPED.
                     4. The feed will log the message when no shipment found for the required shipment status, else it will prepare
                        the items for which shipment is marked as SHIPMENT_SHIPPED.
                     -->
                <if condition="shipmentItemList"><then>
                    <set field="shipmentItemFirst" from="shipmentItemList[0]"/>
                    <!-- Get all Party Identifications for a partyId -->
                    <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                        <econdition field-name="partyId" from="shipmentItemFirst.customerPartyId"/>
                    </entity-find>

                    <!-- Prepare the order details -->
                    <set field="orderInfoMap" from="[orderName:shipmentItemFirst.orderName, orderDate:shipmentItemFirst.orderDate,
                        orderStatusId:shipmentItemFirst.orderStatusId, orderExternalId:shipmentItemFirst.orderExternalId,
                        entryDate:shipmentItemFirst.entryDate, grandTotal:shipmentItemFirst.grandTotal,
                        customerFirstName:shipmentItemFirst.customerFirstName, customerLastName:shipmentItemFirst.customerLastName,
                        currency:shipmentItemFirst.currency, salesChannel:shipmentItemFirst.salesChannel,
                        customerPartyId:shipmentItemFirst.customerPartyId]"/>
                </then><else>
                    <log message="Not preparing the order item details for the order ${erpFulfilledOrder.orderId}, since no shipment found with SHIPMENT_SHIPPED status for the order."/>
                    <continue/>
                </else>
                </if>

                <!-- Prepare the Order Detail map -->
                <set field="orderDetail" from="erpFulfilledOrder.getMap() + orderInfoMap +
                    [isShippingChargesSent:isShippingChargesSent,
                    orderIdentifications:orderIdentificationList, orderAttributes:orderAttributeList,
                    customerPartyIdentifications:partyIdentificationList?:[],
                    payments:orderPaymentPreferenceList, billTo:billToAddress,
                    orderAdjustments:orderAdjustmentList, shipments:shipments]"/>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetail)
                </script>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.info("Error preparing fulfilled order items Feed file", e)
                    }
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                    in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                    messageText:jsonFilePathRef, productStoreId:productStoreId, shopId:customParametersMap?.shopId]" out-map="fulfillmentFeedSysMsgOut"/>
            <return message="Completed ERP Fulfilled Order Items Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${fulfillmentFeedSysMsgOut.systemMessageId}"/>
        </actions>
    </service>

    <!-- Core Service to prepare the order items list as per HotWax Fulfilled Order Items JSON -->
    <service verb="get" noun="OrderItems" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to prepare Order Item details as a list.
            This service requires an orderId, and optionally a orderItemSeqIds list to prepare the list
            of order items.
            NOTE This service is being used as a core service to get the order items list in a specific
            HotWax schema to prepare the fulfilled order items feed to be sent to Shopify and/or ERP.
        </description>
        <in-parameters>
            <parameter name="orderId" required="true">
                <description>The unique ID assigned to the order in OMS.</description>
            </parameter>
            <parameter name="orderItemSeqIds" type="List">
                <description>
                    The list of unique IDs assigned to the order items in OMS.
                    For passing the orderItemSeqIds as list, add values like -
                    00101,00102 and for single value use - 00101
                </description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="orderItems" type="List">
                <description>The list of order items.</description>
            </parameter>
        </out-parameters>
        <actions>
            <log message="Preparing orderItemsList for the order ${orderId} and items ${orderItemSeqIds}"/>

            <!-- Set order items List to add the item map -->
            <set field="orderItems" from="[]"/>

            <!-- Fetch all  Items level details to prepare the Items list -->
            <entity-find entity-name="co.hotwax.warehouse.OrderItemShipmentDetail" list="orderItemShipmentList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderItemSeqId" operator="in" from="orderItemSeqIds" ignore-if-empty="true"/>
            </entity-find>

            <!-- Prepare additional information for each order item -->
            <iterate list="orderItemShipmentList" entry="orderItem">

                <!-- Get all Good Identifications for Product -->
                <entity-find entity-name="org.apache.ofbiz.product.product.GoodIdentification" list="goodIdentificationList">
                    <econdition field-name="productId" from="orderItem.productId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get all Order Item Adjustments -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderItemAdjustmentList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                    <select-field field-name="orderAdjustmentId,orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <!-- Get all Order Item Attributes -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderItemAttribute" list="orderItemAttributeList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderItemSeqId" from="orderItem.orderItemSeqId"/>
                </entity-find>

                <!-- There may be scenario when only a few facilities from all the facilities set-up are being used for external fulfillment.
                 For this, separate Facility Group could be created for such facilities, eg. Facility Group for NetSuite Fulfillment.
                 There could be further requirement to send orders to the external system which are fulfilled to the facilities belonging to a specific Facility Group eg. NetSuite Fulfillment.
                 In the HC Fulfilled Order Items Feed, all the facility group members of the fulfilled facility will be fetched.
                 In the Jolt Transform, order items can be further filtered out on the basis of Facility Group Id to send order items of a particular Facility Group.
                 TODO: For now we are using Facility Group Id for such checks, NOTE that Facility Group Type is not being used as the Facility Group Id will always be unique here, If needed in future, we can create view using FacilityGroup and FacilityGroupMember entities to include Facility Group type info as well. -->
                <entity-find entity-name="org.apache.ofbiz.product.facility.FacilityGroupMember" list="facilityGroupMemberList">
                    <econdition field-name="facilityId" from="orderItem.facilityId"/>
                    <date-filter/>
                </entity-find>

                <set field="orderItemDetail" from="orderItem.getMap() +
                        [goodIdentifications:goodIdentificationList, orderItemAdjustments:orderItemAdjustmentList,
                        orderItemAttributes:orderItemAttributeList, facilityGroupMembers:facilityGroupMemberList]"/>
                <script>
                    orderItems.add(orderItemDetail)
                </script>
            </iterate>
        </actions>
    </service>

    <service verb="generate" noun="FulfilledOrderItemsFeedForShopify" authenticate="anonymous-all" transaction-timeout="7200">
        <description>
            Service to generate Fulfilled Order Items Feed for Shopify. The feed format is a JSON.
            The JSON includes information order-wise with each order containing shipments
            list which is generated by grouping order by trackingIdNumber, carrierPartyId,
            shipmentMethodTypeId and shipToContactMechId, each shipment containing  its completed items.

            This history entity used for the feed is OrderFulfillmentHistory which will contain records
            for the order items sent as part of this feed so that items are not sent multiple times
            to the external system.
        </description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID for generating the Fulfilled Order Items Feed for Shopify.</description>
            </parameter>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating the Fulfilled Order Items Feed for Shopify.</description>
            </parameter>
            <parameter name="orderId">
                <description>Parameter to fetch fulfilled order item details for a specific orderId.</description>
            </parameter>
            <parameter name="orderItemSeqId">
                <description>Parameter to fetch fulfilled order item details for a specific orderItemSeqId.</description>
            </parameter>
            <parameter name="orderTypeId" default-value="SALES_ORDER">
                <description>
                    The parameter fetches fulfilled order item details for a specific Order Type ID (e.g., SALES_ORDER, TRANSFER_ORDER).
                    If no value is passed, the default feed for SALES_ORDER will be generated.
                </description>
            </parameter>
            <parameter name="sinceDate">
                <description>Parameter to fetch fulfilled order items after a specified date.</description>
            </parameter>
            <parameter name="parentFacilityTypeIds" type="List">
                <description>
                    List of parent Facility Type Ids for generating Fulfilled Order Items Feed.
                    For passing the parent Facility Type Ids as list, add values like - PHYSICAL_STORE,DISTRIBUTION_CENTER VIRTUAL_FACILITY and for single value use - PHYSICAL_STORE.
                </description>
            </parameter>
            <parameter name="productTypeIds" type="List">
                <description>
                    List of product Type Ids for generating Fulfilled Order Items Feed.
                    For passing the Product Type Ids as list, add values like -
                    FINISHED_GOOD,DIGITAL_GOOD,DONATION and for single value use - FINISHED_GOOD.
                </description>
            </parameter>
            <parameter name="productStoreIds" type="List">
                <description>
                    List of product Store Ids for generating Fulfilled orders item feed.
                    For passing the Product Store Ids as list, add values like - SM_STORE,SG_STORE
                    and for single value use - SM_STORE.
                </description>
            </parameter>
            <parameter name="isPhysical">
                <description>
                    For passing the IsPhysical values like
                    1. isPhysical = 'Y' - Include Physical good type items.
                    2. isPhysical = 'N' - Include all the type of goods excluding the Physical good type items.
                    3. If we are not passing anything in the isPhysical then all the type of goods will be
                    considered for the feed.
                </description>
            </parameter>
            <parameter name="customParametersMap" type="Map">
                <description>
                    This map defines custom conditions to fetch Fulfilled Order Items, allowing flexibility to add new conditions
                    dynamically. This parameter expects map in a specific format including suffixes like *_op for operators and *_ic
                    for case-insensitivity. Eg. If we want to fetch orders bases on Shopify Shop set up i.e. orders for a particular
                    shopId, we can add the map like {"shopId": "SMUS_SHOP"}.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <set field="nowDate" from="ec.user.nowTimestamp"/>

            <log message="Generating Fulfilled Order Items Feed file of HotWax to Shopify for parentFacilityTypeId ${parentFacilityTypeIds}, Order ${orderId}, at time ${nowDate}"/>

            <!-- Fetch all Orders from FulfilledOrdersItemsForShopify view to be included in
            the Fulfilled Order Items Feed, select-field values for only order level details -->
            <script>
                import com.fasterxml.jackson.core.JsonGenerator
                import com.fasterxml.jackson.core.JsonFactory
                import com.fasterxml.jackson.databind.ObjectMapper
                import java.nio.charset.StandardCharsets
                import org.moqui.entity.EntityCondition

                shopifyFulfilledOrders_find = ec.entity.find("co.hotwax.warehouse.FulfilledOrdersItemsForShopify")
                    .searchFormMap(customParametersMap, null, "", "", false)
                    .condition("itemStatusId", "ITEM_COMPLETED")
                    .condition("orderTypeId", orderTypeId)
                if(orderId) shopifyFulfilledOrders_find.condition("orderId", orderId)
                if(orderItemSeqId) shopifyFulfilledOrders_find.condition("orderItemSeqId", orderItemSeqId)
                if(isPhysical) shopifyFulfilledOrders_find.condition("isPhysical", isPhysical)
                if(parentFacilityTypeIds) shopifyFulfilledOrders_find.condition("parentFacilityTypeId", EntityCondition.ComparisonOperator.IN, parentFacilityTypeIds)
                if(productStoreIds) shopifyFulfilledOrders_find.condition("productStoreId", EntityCondition.ComparisonOperator.IN, productStoreIds)
                if(productTypeIds) shopifyFulfilledOrders_find.condition("productTypeId", EntityCondition.ComparisonOperator.IN, productTypeIds)
                <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                this can be needed where we want to ignore some historical data which is not required to sync. -->
                if(sinceDate) shopifyFulfilledOrders_find.havingCondition(ec.entity.conditionFactory.makeCondition("statusDatetime", EntityCondition.ComparisonOperator.GREATER_THAN, sinceDate))
                <!-- Select-fields to first identify eligible orders for the feed  -->
                shopifyFulfilledOrders_find.selectField("orderId,productStoreId,shopId")
                    .orderBy("statusDatetime")

                // Using try-with-resources to automatically close the EntityListIterator 'shopifyFulfilledOrdersItr'
                try (shopifyFulfilledOrdersItr = shopifyFulfilledOrders_find.iterator()) {
            </script>

            <!-- If no orders in FulfilledOrderItemsSyncQueue, then don't generate the file -->
            <if condition="!shopifyFulfilledOrdersItr.hasNext()">
                <return message="No eligible orders for Shopify Fulfilled Order Items Feed at ${nowDate}, not generating the HotWax Feed file."/>
            </if>

            <!-- Check if nothing is passed in productStoreIds or more than one productStoreIds are passed in the list,
              then set the productStoreId to a default value as the feed being generated contains the Fulfilled order items for more than one product store ids. -->
            <!-- If productStoreIds list contains one value then set the productStoreId from the list. -->
            <set field="productStoreId" from="(!productStoreIds || productStoreIds.size() > 1) ? System.getProperty('hotwax_feed_default_prefix') : productStoreIds[0]"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime for creating feeds.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>
            <if condition="systemMessageType == null"><return error="true" message="Could not find SystemMessageType with ID ${systemMessageTypeId}"/></if>

            <!-- Prepare fulfilled order items JSON File Path -->
            <!-- Using receivePath from SystemMessageType to prepare the jsonFilePathRef.-->
            <set field="jsonFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                        [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', date:ec.l10n.format(nowDate, 'yyyy-MM-dd'), dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS'),
                        productStoreId:productStoreId,shopId:customParametersMap?.shopId], false)"/>
            <set field="jsonFilePath" from="ec.resource.getLocationReference(jsonFilePathRef).getUri().getPath()"/>

            <!-- Prepare the Fulfilled Order Items Feed file  -->
            <script>
                try {
                    //json file
                    File shopifyFulfilledOrderItemsFeedFile = new File(jsonFilePath)
                    if (!shopifyFulfilledOrderItemsFeedFile.parentFile.exists()) shopifyFulfilledOrderItemsFeedFile.parentFile.mkdirs()
                    JsonFactory jfactory = new JsonFactory()

                    /* Declaring the PrintWriter and JsonGenerator resources in the try statement,
                        so that they are automatically closed regardless of whether the try statement completes normally or abruptly. */
                    try (PrintWriter pw = new PrintWriter(StandardCharsets.UTF_8, shopifyFulfilledOrderItemsFeedFile);
                        JsonGenerator jGenerator = jfactory.createGenerator(pw)) {
                        jGenerator.writeStartArray()
            </script>

            <iterate list="shopifyFulfilledOrdersItr" entry="shopifyFulfilledOrder">
                <log message="======== Generating feed for the order ${shopifyFulfilledOrder.orderId} ======="/>

                <!-- Set shipments List to add the shipment details map -->
                <set field="shipments" from="[]"/>

                <!-- Prepare the Order level adjustments list -->
                <!-- The Order level adjustments will include adjustments like Shipping Charges, Shipping Sales Tax,
                    Shipping Adjustments etc. -->

                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAdjustment" list="orderAdjustmentsList">
                    <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                    <econdition field-name="orderItemSeqId" value="_NA_"/>
                    <select-field field-name="orderId,orderItemSeqId,orderAdjustmentTypeId,amount"/>
                </entity-find>

                <!-- NOTE:  Here previously we are fetching the Shipping Charges and Shipping Sales Tax from FulfilledOrderAdjustmentAndHistory View
                and history is created in the FulfilledOrderAdjustmentHistory to check for the order level adjustments that has been already sent in the previous feed,
                As we are sending the same feed to both Shopify and EPR systems.
                Now the feed for Shopify and ERP systems as been separated. In Shopify, we do not require to prepare the order Adjustments and maintains the record in history.-->
                <!-- TODO: Revisit this if any issues faced -->

                <!-- Get all the Payment Preferences for the orderId ID -->
                <!-- 1. Condition added to exclude payment preferences for the statusId='PAYMENT_REFUNDED'
                        as it is not applicable for Fulfilled Order Items Feed.
                     2. For the Order Payment Preference list for the Fulfilled Order Items Feed, the scenarios
                        are identified when Order Payment Preference status is either Authorised or Settled.
                     3. The Settled Status is observed for the payment method types like Shop Pay Installment -->
                <!-- NOTE: The results are ordered by the createdDate to get the oldest payment preference record first in the list.
                     This is done to handle the scenario of multipart payment, that will have multiple records of a statusId for a given
                     orderId. Further handling can be done in the custom transformations as required. -->
                <entity-find entity-name="co.hotwax.financial.OrderPaymentPreferenceAndType" list="orderPaymentPreferenceList">
                    <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                    <econdition field-name="statusId" operator="not-equals" value="PAYMENT_REFUNDED"/>
                    <order-by field-name="createdDate"/>
                </entity-find>

                <!-- Get the contactMechId from OrderContactMech to fetch the billing details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderContactMech" list="orderContactMechList">
                    <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                    <econdition field-name="contactMechPurposeTypeId" operator="in" value="BILLING_LOCATION,BILLING_EMAIL,PHONE_BILLING,SHIPPING_EMAIL"/>
                    <order-by field-name="-lastUpdatedStamp"/>
                </entity-find>

                <!-- If orderContactMechList then fetch the billTo details using the contactMechIds -->
                <if condition="orderContactMechList">
                    <set field="billToAddressContactMechId" from="orderContactMechList.find{ 'BILLING_LOCATION'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="billToEmailOrderContactMech" from="orderContactMechList.find{ 'BILLING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>
                    <set field="billToPhoneContactMechId" from="orderContactMechList.find{ 'PHONE_BILLING'.equals(it.contactMechPurposeTypeId) }?.contactMechId"/>
                    <set field="shipToEmailOrderContactMech" from="orderContactMechList?.find{ 'SHIPPING_EMAIL'.equals(it.contactMechPurposeTypeId) }"/>

                    <if condition="billToAddressContactMechId">
                        <!-- Get the BillTo Postal Address Details -->
                        <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="billToAddressMap">
                            <field-map field-name="contactMechId" from="billToAddressContactMechId"/>
                        </entity-find-one>
                    </if>

                    <if condition="billToEmailOrderContactMech">
                        <!-- Get the BillTo Email Address Details -->
                        <entity-find-related-one value-field="billToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="billToEmailContactMech"/>
                    </if>

                    <if condition="billToPhoneContactMechId">
                        <!-- Get the BillTo Phone Number Details -->
                        <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="billToPhoneDetails">
                            <field-map field-name="contactMechId" from="billToPhoneContactMechId"/>
                        </entity-find-one>
                    </if>
                </if>

                <!-- Adding the Email and Phone number details to billTo Map -->
                <!-- ToDo: Improve the schema of the billTo details map to have address map for postal details. Linked the related
                            issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                <set field="billToAddress" from="billToAddressMap ? billToAddressMap.getMap() : [:] "/>
                <set field="billToAddress.email" from="billToEmailContactMech?.infoString"/>
                <set field="billToAddress.phone" from="billToPhoneDetails"/>

                <!-- Fetch all Order Identifications for the Order ID -->
                <entity-find entity-name="co.hotwax.order.OrderIdentification" list="orderIdentificationList">
                    <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                    <date-filter/>
                </entity-find>

                <!-- Get order attributes details -->
                <entity-find entity-name="org.apache.ofbiz.order.order.OrderAttribute" list="orderAttributesList">
                    <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                </entity-find>

                <!-- Fetch all Shipment details to prepare the Shipment level and Shipment Item level list -->
               <entity-find entity-name="co.hotwax.warehouse.OrderItemShipmentForShopify" list="orderShipmentList">
                   <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                   <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                   <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                   <!-- Completed order items with 'DIGITAL_GOOD' product types,such product types are completed but no shipments are created.
                   because digital type order items are not fulfilled. So if we use econdition with shipmentStatusId ='SHIPMENT_SHIPPED',
                   then we will miss digital types order items.So for also including the digital type goods we use the or-null="true" attribute.
                   If shipmentStatusId is null then compare with the null value and fetch the record accordingly. -->
                   <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED" or-null="true"/>
                   <econdition field-name="isPhysical" ignore-if-empty="true"/>
                   <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                   <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                   <!-- The conditions above needs to be added for fetching the order shipments for the order -->
                   <having-econditions>
                       <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                       this can be needed where we want to ignore some historical data which is not required to sync. -->
                       <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                   </having-econditions>
                   <!-- Select-fields to now identify eligible order shipments for the order  -->
                   <select-field field-name="trackingNumber,carrierPartyId,actualCarrierCode,shipmentMethodTypeId,shipToContactMechId,shipToTelecomContactMechId"/>
                   <order-by field-name="statusDatetime"/>
               </entity-find>

                <iterate list="orderShipmentList" entry="orderShipment">

                    <!-- Set shipmentItems List to add the shipment Items map -->
                    <set field="shipmentItems" from="[]"/>

                    <!-- Prepare Ship To Address details using PostalAddressView -->
                    <!-- NOTE:
                        1. Preparing the Ship To Address from the contactMechId in Shipment only.
                        2. Shipments are created for physical type goods so for them contactMechId will be taken from Shipment.
                        3. For digital type goods there are no shipments. So, Ship To Address will not be prepared. -->
                    <entity-find-one entity-name="co.hotwax.financial.PostalAddressView" value-field="shipToAddressMap">
                        <field-map field-name="contactMechId" from="orderShipment.shipToContactMechId"/>
                    </entity-find-one>

                    <!-- Get the Email Address Details -->
                    <if condition="shipToEmailOrderContactMech">
                        <entity-find-related-one value-field="shipToEmailOrderContactMech" relationship-name="org.apache.ofbiz.party.contact.ContactMech" to-value-field="shipToEmailContactMech"/>
                    </if>

                    <!-- Get the Phone Number Details -->
                    <!-- TODO: TelecomContactMechId is from shipment entity, this should be handled. If the TelecomContactMechId is not found in shipment entity
                    then it should be fetched from OrderItemShipGroup entity. The way it is done for postalContactMechId.
                    Related issue link: https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/445 -->
                    <entity-find-one entity-name="org.apache.ofbiz.party.contact.TelecomNumber" value-field="shipToPhoneDetails">
                        <field-map field-name="contactMechId" from="orderShipment.shipToTelecomContactMechId"/>
                    </entity-find-one>

                    <!-- Adding the Email and Phone number details to shipTo Map -->
                    <!-- ToDo: Improve the schema of the shipTo details map to have address map for postal details. Linked the related
                    issue for more information https://git.hotwax.co/HC2/plugins/ofbiz-oms-usl/-/issues/437 -->
                    <set field="shipToAddress" from="shipToAddressMap ? shipToAddressMap?.getMap() : [:] "/>
                    <set field="shipToAddress.email" from="shipToEmailContactMech?.infoString"/>
                    <set field="shipToAddress.phone" from="shipToPhoneDetails"/>

                    <!-- Preparing trackingUrl -->
                    <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                        Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                        in HC like - partyId.toLowerCase + '.trackingUrl' -->
                    <set field="trackingUrl" value=""/>
                    <set field="orderShipmentCarrier" from="orderShipment.actualCarrierCode ? orderShipment.actualCarrierCode.toLowerCase() : orderShipment.carrierPartyId?.toLowerCase()"/>
                    <if condition="orderShipmentCarrier">
                        <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                            <field-map field-name="systemResourceId" from="orderShipmentCarrier"/>
                            <field-map field-name="systemPropertyId" from="orderShipmentCarrier + '.trackingUrl'"/>
                        </entity-find-one>

                        <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                        <if condition="systemProperty">
                            <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:orderShipment.trackingNumber])"/>
                        </if>
                    </if>

                    <!-- Fetch all Shipped Order Items to prepare the Shipment Item list -->
                    <entity-find entity-name="co.hotwax.warehouse.OrderItemShipmentForShopify" list="fulfilledItemList">
                        <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                        <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="itemStatusId" value="ITEM_COMPLETED"/>
                        <!-- Completed order items with 'DIGITAL_GOOD' product types,such product types are completed but no shipments are created.
                        because digital type order items are not fulfilled. So if we use econdition with shipmentStatusId ='SHIPMENT_SHIPPED',
                        then we will missed digital types order items.So for also including the digital type goods we use the or-null="true" attribute.
                        If shipmentStatusId is null then compare with the null value and fetch the record accordingly. -->
                        <econdition field-name="shipmentStatusId" value="SHIPMENT_SHIPPED" or-null="true"/>
                        <econdition field-name="isPhysical" ignore-if-empty="true"/>
                        <econdition field-name="parentFacilityTypeId" operator="in" from="parentFacilityTypeIds" ignore-if-empty="true"/>
                        <econdition field-name="productTypeId" operator="in" from="productTypeIds" ignore-if-empty="true"/>
                        <!-- The conditions below needs to be added as we have grouped order shipments based
                            on these fields above, and now we want to fetch shipment items for each shipment. -->
                        <econdition field-name="trackingNumber" from="orderShipment.trackingNumber"/>
                        <econdition field-name="actualCarrierCode" from="orderShipment.actualCarrierCode"/>
                        <econdition field-name="carrierPartyId" from="orderShipment.carrierPartyId"/>
                        <econdition field-name="shipmentMethodTypeId" from="orderShipment.shipmentMethodTypeId"/>
                        <econdition field-name="shipToContactMechId" from="orderShipment.shipToContactMechId"/>
                        <econdition field-name="shipToTelecomContactMechId" from="orderShipment.shipToTelecomContactMechId"/>
                        <having-econditions>
                            <!-- Condition on date is added to handle scenario where we want to fetch data after a particular date,
                            this can be needed where we want to ignore some historical data which is not required to sync. -->
                            <econdition field-name="statusDatetime" operator="greater" from="sinceDate" ignore-if-empty="true"/>
                        </having-econditions>
                        <select-field field-name="orderId,orderItemSeqId"/>
                        <order-by field-name="statusDatetime"/>
                    </entity-find>

                    <set field="orderItemSeqIdList" from="fulfilledItemList*.orderItemSeqId"/>

                    <!-- Call the core service to fetch the order items list as per HotWax JSON schema -->
                    <service-call name="co.hotwax.ofbiz.OrderServices.get#OrderItems"
                        in-map="[orderId:shopifyFulfilledOrder.orderId, orderItemSeqIds:orderItemSeqIdList]"
                        out-map="orderItemsOut"/>

                    <set field="shipmentItemList" from="orderItemsOut?.orderItems"/>

                    <!-- Added handling for Kit Product Order Item -->
                    <!-- 1. In HC, the productTypeId for kit product is MARKETING_PKG_PICK and for this product type's fulfillment,
                        its component product order items are fulfilled i.e. Shipment in HC is created for the component
                        order items and not the kit product order item, and so the tracking details need to be fetched from the
                        component shipment items. NOTE that the kit product order item is also marked as completed once
                        the components are fulfilled.
                        2. The details like trackingUrl, trackingNumber, carrierPartyId and the shipmentMethodTypeId is prepared for
                        the kit product order item by adding separate shipment group map in the HC JSON so that it can be handled
                        separately in the transforms for HC to Shopify fulfillment.  -->
                    <set field="shipmentItemProductTypeList" from="orderItemsOut?.orderItems*.productTypeId"/>

                    <if condition="shipmentItemProductTypeList.contains('MARKETING_PKG_PICK')"><then>

                        <!-- Case 1: Multiple Kit Products - same shipment
                             Case 2: Multiple Kit Products - different shipments
                             NOTE Handling is done to always create 1 shipment group for each kit product -->
                        <iterate list="shipmentItemList" entry="shipmentItem">
                            <!-- Fetch the shipment level details from OrderItemAssocAndShipment view like the carrierPartyId, trackingCode and shipmentMethodTypeId for the kit product. -->
                            <!-- NOTE: This view has the shipment details of the component order items associated with the kit product order item. -->
                            <entity-find entity-name="co.hotwax.warehouse.OrderItemAssocAndShipment" list="orderItemAssocAndShipmentList">
                                <econdition field-name="orderId" from="shopifyFulfilledOrder.orderId"/>
                                <econdition field-name="orderItemSeqId" from="shipmentItem.orderItemSeqId"/>
                                <econdition field-name="toOrderId" from="shopifyFulfilledOrder.orderId"/>
                                <econdition field-name="orderItemAssocTypeId" value="KIT_COMPONENT"/>
                            </entity-find>

                            <set field="orderItemAssocAndShipmentFirst" from="orderItemAssocAndShipmentList?.first"/>
                            <!-- Check if the first item exists, then prepare the shipment level details for that
                                kit product order item, else the shipment level details will be set null and trackingUrl will be empty string -->
                            <if condition="orderItemAssocAndShipmentFirst"><then>
                                <!-- Preparing trackingUrl -->
                                <!-- For this, we use SystemProperty entity. For this, the SystemResourceId  is always the
                                    Carrier Party Id in lowercase, and the systemResourceId is always in the fixed pattern
                                    in HC like - partyId.toLowerCase + '.trackingUrl' -->
                                <set field="trackingUrl" value=""/>
                                <set field="orderItemAssocAndShipmentCarrier" from="orderItemAssocAndShipmentFirst.actualCarrierCode ? orderItemAssocAndShipmentFirst.actualCarrierCode.toLowerCase() : orderItemAssocAndShipmentFirst.carrierPartyId?.toLowerCase()"/>
                                <if condition="orderItemAssocAndShipmentCarrier">
                                    <entity-find-one entity-name="org.apache.ofbiz.common.property.SystemProperty" value-field="systemProperty" cache="true">
                                        <field-map field-name="systemResourceId" from="orderItemAssocAndShipmentCarrier"/>
                                        <field-map field-name="systemPropertyId" from="orderItemAssocAndShipmentCarrier + '.trackingUrl'"/>
                                    </entity-find-one>

                                    <!-- If systemPropertyValue exists, then prepare the trackingUrl -->
                                    <if condition="systemProperty">
                                        <set field="trackingUrl" from="ec.resource.expand(systemProperty.systemPropertyValue, null, [trackingNumber:orderItemAssocAndShipmentFirst.trackingNumber])"/>
                                    </if>
                                </if>
                            </then><else>
                                <log level="warn" message="Order Item record not found in OrderItemAssocAndShipment, not preparing Shipment level details for OrderId ${shipmentItem.orderId} and shipmentItem ${shipmentItem.orderItemSeqId}"/>
                            </else></if>

                            <!-- TODO: Prepare shipTo details for the ship group of kit products in HC JSON, for now setting it as null. -->
                            <set field="shipmentDetail" from="[trackingNumber:orderItemAssocAndShipmentFirst?.trackingNumber,
                            carrierPartyId:orderItemAssocAndShipmentFirst?.carrierPartyId,
                            actualCarrierCode:orderItemAssocAndShipmentFirst?.actualCarrierCode,
                            shipmentMethodTypeId:orderItemAssocAndShipmentFirst?.shipmentMethodTypeId,
                            trackingUrl:trackingUrl, shipTo:null, shipmentItems:[shipmentItem]]"/>

                            <script>shipments.add(shipmentDetail)</script>
                        </iterate>
                    </then><else>
                        <set field="shipmentDetail" from="[trackingNumber:orderShipment.trackingNumber,
                            carrierPartyId:orderShipment.carrierPartyId,
                            actualCarrierCode:orderShipment.actualCarrierCode,
                            shipmentMethodTypeId:orderShipment.shipmentMethodTypeId,
                            trackingUrl:trackingUrl, shipTo:shipToAddress,
                            shipmentItems:shipmentItemList]"/>

                        <script>shipments.add(shipmentDetail)</script>
                    </else></if>

                    <iterate list="shipmentItemList" entry="shipmentItem">
                        <!--Create record of OrderFulfillmentHistory to keep logs for the Fulfilled Order and Items Feed for Shopify-->
                            <service-call name="create#co.hotwax.integration.order.OrderFulfillmentHistory"
                                in-map="[orderId:shipmentItem.orderId, orderItemSeqId:shipmentItem.orderItemSeqId,
                                shipmentId:shipmentItem.shipmentId, createdDate:nowDate,
                                comments:'Order Item sent as part of Fulfilled Items Feed to Shopify']"/>
                    </iterate>

                </iterate>

                <!-- Set orderInfoMap to prepare some of the order level details from shipmentItem map -->
                <set field="orderInfoMap" from="[:]"/>
                <!-- The null check on shipmentItem is added to handle NPE for the scenario when items are completed but shipment is not marked as
                     SHIPMENT_SHIPPED, this has been encountered in HC while preparing the Fulfilled Items Feed for Shopify.
                     NOTE:
                     1. Without this check, the entire feed gets stuck as no handling for such scenario, when the issue may be with
                        only few order items. This is because the shipments and its items are fetched using the shipment status
                        check on SHIPMENT_SHIPPED value.
                     2. With this check, the order items will not be prepared for this scenario but order level details will be
                        prepared which may be helpful for quick analysis.
                     3. Separate report has been scheduled to alert for such orders where items are completed but the shipment could
                        not be marked as SHIPMENT_SHIPPED.
                     4. The feed will log the message when no shipment found for the required shipment status, else it will prepare
                        the items for which shipment is marked as SHIPMENT_SHIPPED.
                -->
                <if condition="shipmentItemList"><then>
                    <set field="shipmentItemFirst" from="shipmentItemList[0]"/>
                    <!-- Get all Party Identifications for a partyId -->
                    <entity-find entity-name="org.apache.ofbiz.party.party.PartyIdentification" list="partyIdentificationList">
                        <econdition field-name="partyId" from="shipmentItemFirst.customerPartyId"/>
                    </entity-find>

                    <!-- Prepare the order details -->
                    <set field="orderInfoMap" from="[orderName:shipmentItemFirst.orderName, orderDate:shipmentItemFirst.orderDate,
                        orderStatusId:shipmentItemFirst.orderStatusId, orderExternalId:shipmentItemFirst.orderExternalId, entryDate:shipmentItemFirst.entryDate, grandTotal:shipmentItemFirst.grandTotal,
                        customerFirstName:shipmentItemFirst.customerFirstName, customerLastName:shipmentItemFirst.customerLastName,
                        currency:shipmentItemFirst.currency, salesChannel:shipmentItemFirst.salesChannel, customerPartyId:shipmentItemFirst.customerPartyId]"/>
                </then><else>
                    <log message="Not preparing the order item details for the order ${shopifyFulfilledOrder.orderId}, since no shipment found with SHIPMENT_SHIPPED status for the order."/>
                    <continue/>
                </else>
                </if>

                <!-- Prepare the Order Detail map -->
                <set field="orderDetail" from="shopifyFulfilledOrder.getMap() + orderInfoMap + [orderIdentifications:orderIdentificationList, orderAttributes:orderAttributesList,
                    customerPartyIdentifications:partyIdentificationList?:[], payments:orderPaymentPreferenceList, billTo:billToAddress,
                    orderAdjustments:orderAdjustmentsList, shipments:shipments]"/>
                <script>
                    new ObjectMapper()
                    .setDateFormat(new java.text.SimpleDateFormat(System.getProperty('default_date_time_format')))
                    .writerWithDefaultPrettyPrinter().writeValue(jGenerator, orderDetail)
                </script>
            </iterate>
            <script>
                        jGenerator.writeEndArray()
                    }
                } catch (IOException e) {
                    logger.info("Error preparing fulfilled order items Feed file", e)
                }
                }
            </script>

            <!-- Save the Json Feed File path in System Message messageText -->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage"
                in-map="[systemMessageTypeId:systemMessageTypeId, systemMessageRemoteId:systemMessageRemoteId,
                messageText:jsonFilePathRef, productStoreId:productStoreId, shopId:customParametersMap?.shopId]" out-map="fulfillmentFeedSysMsgOut"/>
            <return message="Completed Shopify Fulfilled Order Items Feed file at time ${ec.user.nowTimestamp} with type ${systemMessageTypeId} and
                remote ${systemMessageRemoteId} saved response in messages ${fulfillmentFeedSysMsgOut.systemMessageId}"/>
        </actions>
    </service>
</services>
